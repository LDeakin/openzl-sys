/* automatically generated by rust-bindgen 0.72.1 */

pub const ZL_ERROR_ENABLE_STATIC_ERROR_INFO: u32 = 1;
pub const ZL_ErrorCode_no_error__desc_str: &[u8; 9] = b"No Error\0";
pub const ZL_ErrorCode_GENERIC__desc_str: &[u8; 8] = b"Generic\0";
pub const ZL_ErrorCode_allocation__desc_str: &[u8; 11] = b"Allocation\0";
pub const ZL_ErrorCode_srcSize_tooSmall__desc_str: &[u8; 22] = b"Source size too small\0";
pub const ZL_ErrorCode_dstCapacity_tooSmall__desc_str: &[u8; 31] =
    b"Destination capacity too small\0";
pub const ZL_ErrorCode_userBuffer_alignmentIncorrect__desc_str: &[u8; 55] =
    b"Buffer provided is incorrectly aligned for target type\0";
pub const ZL_ErrorCode_userBuffers_invalidNum__desc_str: &[u8; 57] =
    b"Nb of Typed Buffers provided is incorrect for this frame\0";
pub const ZL_ErrorCode_decompression_incorrectAPI__desc_str: &[u8; 61] =
    b"Used an invalid decompression API method for the target Type\0";
pub const ZL_ErrorCode_header_unknown__desc_str: &[u8; 15] = b"Unknown header\0";
pub const ZL_ErrorCode_frameParameter_unsupported__desc_str: &[u8; 28] =
    b"Frame parameter unsupported\0";
pub const ZL_ErrorCode_outputID_invalid__desc_str: &[u8; 37] =
    b"Frame doesn't host this many outputs\0";
pub const ZL_ErrorCode_invalidRequest_singleOutputFrameOnly__desc_str: &[u8; 65] =
    b"This request only makes sense for Frames hosting a single Output\0";
pub const ZL_ErrorCode_outputNotCommitted__desc_str: &[u8; 21] = b"Output not committed\0";
pub const ZL_ErrorCode_outputNotReserved__desc_str: &[u8; 21] = b"Output has no buffer\0";
pub const ZL_ErrorCode_compressionParameter_invalid__desc_str: &[u8; 30] =
    b"Compression parameter invalid\0";
pub const ZL_ErrorCode_segmenter_inputNotConsumed__desc_str: &[u8; 46] =
    b"Segmenter did not consume entirely all inputs\0";
pub const ZL_ErrorCode_graph_invalid__desc_str: &[u8; 14] = b"Graph invalid\0";
pub const ZL_ErrorCode_graph_nonserializable__desc_str: &[u8; 38] =
    b"Graph incompatible with serialization\0";
pub const ZL_ErrorCode_graph_invalidNumInputs__desc_str: &[u8; 24] = b"Graph invalid nb inputs\0";
pub const ZL_ErrorCode_successor_invalid__desc_str: &[u8; 36] =
    b"Selected an invalid Successor Graph\0";
pub const ZL_ErrorCode_successor_alreadySet__desc_str: &[u8; 49] =
    b"A Successor was already assigned for this Stream\0";
pub const ZL_ErrorCode_successor_invalidNumInputs__desc_str: &[u8; 53] =
    b"Successor Graph receives an invalid number of Inputs\0";
pub const ZL_ErrorCode_inputType_unsupported__desc_str: &[u8; 42] =
    b"Input Type not supported by selected Port\0";
pub const ZL_ErrorCode_graphParameter_invalid__desc_str: &[u8; 46] =
    b"Graph was assigned an invalid Local Parameter\0";
pub const ZL_ErrorCode_nodeParameter_invalid__desc_str: &[u8; 23] = b"Node parameter invalid\0";
pub const ZL_ErrorCode_nodeParameter_invalidValue__desc_str: &[u8; 29] =
    b"Node parameter invalid value\0";
pub const ZL_ErrorCode_transform_executionFailure__desc_str: &[u8; 34] =
    b"Transform failed during execution\0";
pub const ZL_ErrorCode_customNode_definitionInvalid__desc_str: &[u8; 31] =
    b"Custom node definition invalid\0";
pub const ZL_ErrorCode_stream_wrongInit__desc_str: &[u8; 46] =
    b"Stream is not in a valid initialization stage\0";
pub const ZL_ErrorCode_streamType_incorrect__desc_str: &[u8; 35] =
    b"An incompatible type is being used\0";
pub const ZL_ErrorCode_streamCapacity_tooSmall__desc_str: &[u8; 43] =
    b"Stream internal capacity is not sufficient\0";
pub const ZL_ErrorCode_streamParameter_invalid__desc_str: &[u8; 25] = b"Stream parameter invalid\0";
pub const ZL_ErrorCode_parameter_invalid__desc_str: &[u8; 21] = b"Parameter is invalid\0";
pub const ZL_ErrorCode_formatVersion_unsupported__desc_str: &[u8; 27] =
    b"Format version unsupported\0";
pub const ZL_ErrorCode_formatVersion_notSet__desc_str: &[u8; 84] =
    b"Format version is not set; it must be set via the ZL_CParam_formatVersion parameter\0";
pub const ZL_ErrorCode_node_versionMismatch__desc_str: &[u8; 51] =
    b"Node is incompatible with requested format version\0";
pub const ZL_ErrorCode_node_unexpected_input_type__desc_str: &[u8; 31] =
    b"Unexpected input type for node\0";
pub const ZL_ErrorCode_node_invalid_input__desc_str: &[u8; 48] =
    b"Input does not respect conditions for this node\0";
pub const ZL_ErrorCode_node_invalid__desc_str: &[u8; 16] = b"Invalid Node ID\0";
pub const ZL_ErrorCode_nodeExecution_invalidOutputs__desc_str: &[u8; 69] =
    b"node execution has resulted in an incorrect configuration of outputs\0";
pub const ZL_ErrorCode_nodeRegen_countIncorrect__desc_str: &[u8; 63] =
    b"node is requested to regenerate an incorrect number of streams\0";
pub const ZL_ErrorCode_logicError__desc_str: &[u8; 21] = b"Internal logic error\0";
pub const ZL_ErrorCode_invalidTransform__desc_str: &[u8; 21] = b"Invalid transform ID\0";
pub const ZL_ErrorCode_internalBuffer_tooSmall__desc_str: &[u8; 26] =
    b"Internal buffer too small\0";
pub const ZL_ErrorCode_corruption__desc_str: &[u8; 20] = b"Corruption detected\0";
pub const ZL_ErrorCode_outputs_tooNumerous__desc_str: &[u8; 56] =
    b"Too many outputs: unsupported by claimed format version\0";
pub const ZL_ErrorCode_temporaryLibraryLimitation__desc_str: &[u8; 36] =
    b"Temporary OpenZL library limitation\0";
pub const ZL_ErrorCode_compressedChecksumWrong__desc_str: &[u8; 60] =
    b"Compressed checksum mismatch (corruption after compression)\0";
pub const ZL_ErrorCode_contentChecksumWrong__desc_str : & [u8 ; 114] = b"Content checksum mismatch (either corruption after compression or corruption during compression or decompression)\0" ;
pub const ZL_ErrorCode_srcSize_tooLarge__desc_str: &[u8; 22] = b"Source size too large\0";
pub const ZL_ErrorCode_integerOverflow__desc_str: &[u8; 17] = b"Integer overflow\0";
pub const ZL_ErrorCode_invalidName__desc_str: &[u8; 32] = b"Invalid name of graph component\0";
pub const ZL_ENABLE_RET_IF_ARG_PRINTING: u32 = 1;
pub const ZL_ENABLE_ERR_IF_ARG_PRINTING: u32 = 1;
pub const ZL_LIBRARY_VERSION_MAJOR: u32 = 0;
pub const ZL_LIBRARY_VERSION_MINOR: u32 = 1;
pub const ZL_LIBRARY_VERSION_PATCH: u32 = 0;
pub const ZL_LIBRARY_VERSION_NUMBER: u32 = 100;
pub const ZL_FBCODE_IS_RELEASE: u32 = 0;
pub const ZL_MIN_FORMAT_VERSION: u32 = 8;
pub const ZL_MAX_FORMAT_VERSION: u32 = 21;
pub const ZL_CHUNK_VERSION_MIN: u32 = 21;
pub const ZL_TYPED_INPUT_VERSION_MIN: u32 = 14;
pub const ZL_COMPRESSIONLEVEL_DEFAULT: u32 = 6;
pub const ZL_DECOMPRESSIONLEVEL_DEFAULT: u32 = 3;
pub const ZL_MINSTREAMSIZE_DEFAULT: u32 = 10;
pub const ZL_CONVERT_SERIAL_TO_STRUCT_SIZE_PID: u32 = 1;
pub const ZL_DISPATCH_PARSINGFN_PID: u32 = 519;
pub const ZL_DISPATCH_INSTRUCTIONS_PID: u32 = 520;
pub const ZL_DISPATCH_CHANNEL_ID: u32 = 83;
pub const ZL_DISPATCH_STRING_NUM_OUTPUTS_PID: u32 = 47;
pub const ZL_DISPATCH_STRING_INDICES_PID: u32 = 48;
pub const ZL_DIVIDE_BY_PID: u32 = 112;
pub const ZL_FIELD_LZ_COMPRESSION_LEVEL_OVERRIDE_PID: u32 = 181;
pub const ZL_FIELD_LZ_LITERALS_GRAPH_OVERRIDE_INDEX_PID: u32 = 0;
pub const ZL_FIELD_LZ_TOKENS_GRAPH_OVERRIDE_INDEX_PID: u32 = 1;
pub const ZL_FIELD_LZ_OFFSETS_GRAPH_OVERRIDE_INDEX_PID: u32 = 2;
pub const ZL_FIELD_LZ_EXTRA_LITERAL_LENGTHS_GRAPH_OVERRIDE_INDEX_PID: u32 = 3;
pub const ZL_FIELD_LZ_EXTRA_MATCH_LENGTHS_GRAPH_OVERRIDE_INDEX_PID: u32 = 4;
pub const ZL_SDDL_DESCRIPTION_PID: u32 = 522;
pub const ZL_SPLIT_CHANNEL_ID: u32 = 867;
pub const ZL_TOKENIZE_SORT_PID: u32 = 0;
pub const ZL_HAVE_FBCODE: u32 = 1;
pub const ZL_HAVE_X86_64_ASM: u32 = 1;
pub const ZL_ALLOW_INTROSPECTION: u32 = 1;
pub const ZL_LP_INVALID_PARAMID: i32 = -1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_WBuffer {
    pub start: *mut ::std::os::raw::c_void,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_ZL_WBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_WBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_WBuffer>(),
        16usize,
        "Size of ZL_WBuffer"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_WBuffer>(),
        8usize,
        "Alignment of ZL_WBuffer"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_WBuffer::start"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_WBuffer::capacity"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_WCursor {
    pub wb: ZL_WBuffer,
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_ZL_WCursor() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_WCursor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_WCursor>(),
        24usize,
        "Size of ZL_WCursor"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_WCursor>(),
        8usize,
        "Alignment of ZL_WCursor"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wb) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_WCursor::wb"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_WCursor::pos"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_RBuffer {
    pub start: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_ZL_RBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_RBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_RBuffer>(),
        16usize,
        "Size of ZL_RBuffer"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_RBuffer>(),
        8usize,
        "Alignment of ZL_RBuffer"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_RBuffer::start"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_RBuffer::size"
    );
}
pub type ZL_IDType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DataID {
    pub sid: ZL_IDType,
}
#[test]
fn bindgen_test_layout_ZL_DataID() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_DataID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_DataID>(),
        4usize,
        "Size of ZL_DataID"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_DataID>(),
        4usize,
        "Alignment of ZL_DataID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_DataID::sid"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_NodeID {
    pub nid: ZL_IDType,
}
#[test]
fn bindgen_test_layout_ZL_NodeID() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_NodeID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_NodeID>(),
        4usize,
        "Size of ZL_NodeID"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_NodeID>(),
        4usize,
        "Alignment of ZL_NodeID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_NodeID::nid"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_GraphID {
    pub gid: ZL_IDType,
}
#[test]
fn bindgen_test_layout_ZL_GraphID() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphID>(),
        4usize,
        "Size of ZL_GraphID"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphID>(),
        4usize,
        "Alignment of ZL_GraphID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphID::gid"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Data_s {
    _unused: [u8; 0],
}
pub type ZL_Data = ZL_Data_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Input_s {
    _unused: [u8; 0],
}
pub type ZL_Input = ZL_Input_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Output_s {
    _unused: [u8; 0],
}
pub type ZL_Output = ZL_Output_s;
pub type ZL_TypedRef = ZL_Input;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Compressor_s {
    _unused: [u8; 0],
}
#[doc = " @defgroup Group_Compressor_LifetimeManagement Lifetime Management\n\n @{"]
pub type ZL_Compressor = ZL_Compressor_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CompressorSerializer_s {
    _unused: [u8; 0],
}
pub type ZL_CompressorSerializer = ZL_CompressorSerializer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CompressorDeserializer_s {
    _unused: [u8; 0],
}
pub type ZL_CompressorDeserializer = ZL_CompressorDeserializer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CCtx_s {
    _unused: [u8; 0],
}
pub type ZL_CCtx = ZL_CCtx_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DCtx_s {
    _unused: [u8; 0],
}
#[doc = " @brief Decompression context for state management (incomplete type)."]
pub type ZL_DCtx = ZL_DCtx_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Encoder_s {
    _unused: [u8; 0],
}
pub type ZL_Encoder = ZL_Encoder_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Decoder_s {
    _unused: [u8; 0],
}
pub type ZL_Decoder = ZL_Decoder_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Selector_s {
    _unused: [u8; 0],
}
pub type ZL_Selector = ZL_Selector_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Graph_s {
    _unused: [u8; 0],
}
pub type ZL_Graph = ZL_Graph_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Edge_s {
    _unused: [u8; 0],
}
pub type ZL_Edge = ZL_Edge_s;
pub const ZL_TernaryParam_auto: ZL_TernaryParam = 0;
pub const ZL_TernaryParam_enable: ZL_TernaryParam = 1;
pub const ZL_TernaryParam_disable: ZL_TernaryParam = 2;
pub type ZL_TernaryParam = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_OpaquePtr {
    #[doc = " Opaque pointer that is passed back to the user when calling functions\n like:\n - ZL_Encoder_getOpaquePtr()\n - ZL_Decoder_getOpaquePtr()\n - ZL_Graph_getOpaquePtr()\n - ZL_Selector_getOpaquePtr()"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = " Additional pointer passed to the free function.\n This additional pointer allows, for example, to use a C++ lambda as a\n free function."]
    pub freeOpaquePtr: *mut ::std::os::raw::c_void,
    #[doc = " Frees the ZL_OpaquePtr::ptr, and if needed also the\n ZL_OpaquePtr::freeOpaquePtr. This function is called exactly once by\n OpenZL once the opaque pointer has been registered.\n If freeFn is NULL, then it is not called."]
    pub freeFn: ::std::option::Option<
        unsafe extern "C" fn(
            freeOpaquePtr: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ZL_OpaquePtr() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_OpaquePtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_OpaquePtr>(),
        24usize,
        "Size of ZL_OpaquePtr"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_OpaquePtr>(),
        8usize,
        "Alignment of ZL_OpaquePtr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_OpaquePtr::ptr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeOpaquePtr) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_OpaquePtr::freeOpaquePtr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeFn) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_OpaquePtr::freeFn"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_GraphIDList {
    pub graphids: *const ZL_GraphID,
    pub nbGraphIDs: usize,
}
#[test]
fn bindgen_test_layout_ZL_GraphIDList() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphIDList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphIDList>(),
        16usize,
        "Size of ZL_GraphIDList"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphIDList>(),
        8usize,
        "Alignment of ZL_GraphIDList"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphids) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphIDList::graphids"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbGraphIDs) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_GraphIDList::nbGraphIDs"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_NodeIDList {
    pub nodeids: *const ZL_NodeID,
    pub nbNodeIDs: usize,
}
#[test]
fn bindgen_test_layout_ZL_NodeIDList() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_NodeIDList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_NodeIDList>(),
        16usize,
        "Size of ZL_NodeIDList"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_NodeIDList>(),
        8usize,
        "Alignment of ZL_NodeIDList"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeids) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_NodeIDList::nodeids"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbNodeIDs) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_NodeIDList::nbNodeIDs"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DynamicErrorInfo_s {
    _unused: [u8; 0],
}
#[doc = " Forward Declarations *"]
pub type ZL_DynamicErrorInfo = ZL_DynamicErrorInfo_s;
#[doc = " ZL_StaticErrorInfo *"]
pub type ZL_StaticErrorInfo = ZL_StaticErrorInfo_s;
#[doc = " ZL_Error:\n\n The ZL_Error represents an optional failure. (If _code is\n ZL_ErrorCode_no_error, the object represents a success condition.) Depending\n on how it was constructed, the error may be \"bare\" (_info == NULL) or \"rich\",\n in which case it has an _info struct that can contain additional context and\n information about the error.\n\n The ZL_Error is usually returned-by-value, and therefore the definition\n needs to be publicly available. However, users should not directly interact\n with the members of the struct, and should instead use the various accessors\n and methods made available in the public API."]
pub type ZL_Error = ZL_Error_s;
#[doc = " Internally, there are two kinds of error info objects: dynamic and static,\n which are, like they sound, respectively dynamically allocated (and which\n must be freed) or statically allocated, but which therefore can't contain\n any runtime information.\n\n You should never assign or dereference these pointers directly:\n\n 1. We pack metadata into the unused bits of the pointers, which needs to be\n    masked out to retrieve the actual pointer.\n 2. You need interact with that metadata to figure out or set which pointer\n    is active.\n\n Instead:\n\n You should use @ref ZL_E_dy or @ref ZL_E_st to check for the presence of and\n to extract the (possibly NULL) pointers to the sub-types.\n\n You should use @ref ZL_EI_fromDy or @ref ZL_EI_fromSt to construct this\n object from one of those pointer."]
pub type ZL_ErrorInfo = ZL_ErrorInfo_u;
pub const ZL_ErrorCode_no_error: ZL_ErrorCode = 0;
pub const ZL_ErrorCode_GENERIC: ZL_ErrorCode = 1;
pub const ZL_ErrorCode_srcSize_tooSmall: ZL_ErrorCode = 3;
pub const ZL_ErrorCode_srcSize_tooLarge: ZL_ErrorCode = 4;
pub const ZL_ErrorCode_dstCapacity_tooSmall: ZL_ErrorCode = 5;
pub const ZL_ErrorCode_userBuffer_alignmentIncorrect: ZL_ErrorCode = 6;
pub const ZL_ErrorCode_decompression_incorrectAPI: ZL_ErrorCode = 7;
pub const ZL_ErrorCode_userBuffers_invalidNum: ZL_ErrorCode = 8;
pub const ZL_ErrorCode_invalidName: ZL_ErrorCode = 9;
pub const ZL_ErrorCode_header_unknown: ZL_ErrorCode = 10;
pub const ZL_ErrorCode_frameParameter_unsupported: ZL_ErrorCode = 11;
pub const ZL_ErrorCode_corruption: ZL_ErrorCode = 12;
pub const ZL_ErrorCode_compressedChecksumWrong: ZL_ErrorCode = 13;
pub const ZL_ErrorCode_contentChecksumWrong: ZL_ErrorCode = 14;
pub const ZL_ErrorCode_outputs_tooNumerous: ZL_ErrorCode = 15;
pub const ZL_ErrorCode_compressionParameter_invalid: ZL_ErrorCode = 20;
pub const ZL_ErrorCode_parameter_invalid: ZL_ErrorCode = 21;
pub const ZL_ErrorCode_outputID_invalid: ZL_ErrorCode = 22;
pub const ZL_ErrorCode_invalidRequest_singleOutputFrameOnly: ZL_ErrorCode = 23;
pub const ZL_ErrorCode_outputNotCommitted: ZL_ErrorCode = 24;
pub const ZL_ErrorCode_outputNotReserved: ZL_ErrorCode = 25;
pub const ZL_ErrorCode_segmenter_inputNotConsumed: ZL_ErrorCode = 26;
pub const ZL_ErrorCode_graph_invalid: ZL_ErrorCode = 30;
pub const ZL_ErrorCode_graph_nonserializable: ZL_ErrorCode = 31;
pub const ZL_ErrorCode_invalidTransform: ZL_ErrorCode = 32;
pub const ZL_ErrorCode_graph_invalidNumInputs: ZL_ErrorCode = 33;
pub const ZL_ErrorCode_successor_invalid: ZL_ErrorCode = 40;
pub const ZL_ErrorCode_successor_alreadySet: ZL_ErrorCode = 41;
pub const ZL_ErrorCode_successor_invalidNumInputs: ZL_ErrorCode = 42;
pub const ZL_ErrorCode_inputType_unsupported: ZL_ErrorCode = 43;
pub const ZL_ErrorCode_graphParameter_invalid: ZL_ErrorCode = 44;
pub const ZL_ErrorCode_nodeParameter_invalid: ZL_ErrorCode = 50;
pub const ZL_ErrorCode_nodeParameter_invalidValue: ZL_ErrorCode = 51;
pub const ZL_ErrorCode_transform_executionFailure: ZL_ErrorCode = 52;
pub const ZL_ErrorCode_customNode_definitionInvalid: ZL_ErrorCode = 53;
pub const ZL_ErrorCode_node_unexpected_input_type: ZL_ErrorCode = 54;
pub const ZL_ErrorCode_node_invalid_input: ZL_ErrorCode = 55;
pub const ZL_ErrorCode_node_invalid: ZL_ErrorCode = 56;
pub const ZL_ErrorCode_nodeExecution_invalidOutputs: ZL_ErrorCode = 57;
pub const ZL_ErrorCode_nodeRegen_countIncorrect: ZL_ErrorCode = 58;
pub const ZL_ErrorCode_formatVersion_unsupported: ZL_ErrorCode = 60;
pub const ZL_ErrorCode_formatVersion_notSet: ZL_ErrorCode = 61;
pub const ZL_ErrorCode_node_versionMismatch: ZL_ErrorCode = 62;
pub const ZL_ErrorCode_allocation: ZL_ErrorCode = 70;
pub const ZL_ErrorCode_internalBuffer_tooSmall: ZL_ErrorCode = 71;
pub const ZL_ErrorCode_integerOverflow: ZL_ErrorCode = 72;
pub const ZL_ErrorCode_stream_wrongInit: ZL_ErrorCode = 73;
pub const ZL_ErrorCode_streamType_incorrect: ZL_ErrorCode = 74;
pub const ZL_ErrorCode_streamCapacity_tooSmall: ZL_ErrorCode = 75;
pub const ZL_ErrorCode_streamParameter_invalid: ZL_ErrorCode = 76;
pub const ZL_ErrorCode_logicError: ZL_ErrorCode = 80;
pub const ZL_ErrorCode_temporaryLibraryLimitation: ZL_ErrorCode = 81;
pub const ZL_ErrorCode_maxCode: ZL_ErrorCode = 99;
#[doc = " ZL_ErrorCode *"]
pub type ZL_ErrorCode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_OperationContext_s {
    _unused: [u8; 0],
}
pub type ZL_OperationContext = ZL_OperationContext_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_GraphContext {
    #[doc = " The current nodeID or 0 for unset / unknown."]
    pub nodeID: ZL_NodeID,
    #[doc = " The current graphID or 0 for unset / unknown."]
    pub graphID: ZL_GraphID,
    #[doc = " The current transformID or 0 for unset / unknown."]
    pub transformID: ZL_IDType,
    #[doc = " The name of the component, may be NULL."]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_GraphContext() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphContext>(),
        24usize,
        "Size of ZL_GraphContext"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphContext>(),
        8usize,
        "Alignment of ZL_GraphContext"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeID) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphContext::nodeID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphID) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_GraphContext::graphID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transformID) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_GraphContext::transformID"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_GraphContext::name"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_ErrorContext {
    #[doc = " Pointer to the operation context to store dynamic error info in, or NULL\n to opt out of dynamic error info."]
    pub opCtx: *mut ZL_OperationContext,
    pub graphCtx: ZL_GraphContext,
}
#[test]
fn bindgen_test_layout_ZL_ErrorContext() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_ErrorContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_ErrorContext>(),
        32usize,
        "Size of ZL_ErrorContext"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_ErrorContext>(),
        8usize,
        "Alignment of ZL_ErrorContext"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opCtx) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_ErrorContext::opCtx"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphCtx) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_ErrorContext::graphCtx"
    );
}
extern "C" {
    pub fn ZL_Compressor_getOperationContext(ctx: *mut ZL_Compressor) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_CCtx_getOperationContext(ctx: *mut ZL_CCtx) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_DCtx_getOperationContext(ctx: *mut ZL_DCtx) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_Encoder_getOperationContext(ctx: *mut ZL_Encoder) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_Decoder_getOperationContext(ctx: *mut ZL_Decoder) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_Graph_getOperationContext(ctx: *mut ZL_Graph) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_Edge_getOperationContext(ctx: *mut ZL_Edge) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_CompressorSerializer_getOperationContext(
        ctx: *mut ZL_CompressorSerializer,
    ) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_CompressorDeserializer_getOperationContext(
        ctx: *mut ZL_CompressorDeserializer,
    ) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_ErrorContext_getOperationContext(
        ctx: *mut ZL_ErrorContext,
    ) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_NULL_getOperationContext(
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ZL_OperationContext;
}
extern "C" {
    pub fn ZL_OperationContext_getDefaultErrorContext(
        opCtx: *mut ZL_OperationContext,
    ) -> *mut ZL_ErrorContext;
}
#[doc = " ZL_StaticErrorInfo *"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_StaticErrorInfo_s {
    pub code: ZL_ErrorCode,
    pub fmt: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ZL_StaticErrorInfo_s() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_StaticErrorInfo_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_StaticErrorInfo_s>(),
        40usize,
        "Size of ZL_StaticErrorInfo_s"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_StaticErrorInfo_s>(),
        8usize,
        "Alignment of ZL_StaticErrorInfo_s"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_StaticErrorInfo_s::code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_StaticErrorInfo_s::fmt"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_StaticErrorInfo_s::file"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_StaticErrorInfo_s::func"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_StaticErrorInfo_s::line"
    );
}
#[doc = " Internally, there are two kinds of error info objects: dynamic and static,\n which are, like they sound, respectively dynamically allocated (and which\n must be freed) or statically allocated, but which therefore can't contain\n any runtime information.\n\n You should never assign or dereference these pointers directly:\n\n 1. We pack metadata into the unused bits of the pointers, which needs to be\n    masked out to retrieve the actual pointer.\n 2. You need interact with that metadata to figure out or set which pointer\n    is active.\n\n Instead:\n\n You should use @ref ZL_E_dy or @ref ZL_E_st to check for the presence of and\n to extract the (possibly NULL) pointers to the sub-types.\n\n You should use @ref ZL_EI_fromDy or @ref ZL_EI_fromSt to construct this\n object from one of those pointer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_ErrorInfo_u {
    pub _dy: *mut ZL_DynamicErrorInfo,
    pub _st: *const ZL_StaticErrorInfo,
}
#[test]
fn bindgen_test_layout_ZL_ErrorInfo_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_ErrorInfo_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_ErrorInfo_u>(),
        8usize,
        "Size of ZL_ErrorInfo_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_ErrorInfo_u>(),
        8usize,
        "Alignment of ZL_ErrorInfo_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._dy) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_ErrorInfo_u::_dy"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_ErrorInfo_u::_st"
    );
}
#[doc = " ZL_Error:\n\n The ZL_Error represents an optional failure. (If _code is\n ZL_ErrorCode_no_error, the object represents a success condition.) Depending\n on how it was constructed, the error may be \"bare\" (_info == NULL) or \"rich\",\n in which case it has an _info struct that can contain additional context and\n information about the error.\n\n The ZL_Error is usually returned-by-value, and therefore the definition\n needs to be publicly available. However, users should not directly interact\n with the members of the struct, and should instead use the various accessors\n and methods made available in the public API."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ZL_Error_s {
    pub _code: ZL_ErrorCode,
    pub _info: ZL_ErrorInfo,
}
#[test]
fn bindgen_test_layout_ZL_Error_s() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Error_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Error_s>(),
        16usize,
        "Size of ZL_Error_s"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Error_s>(),
        8usize,
        "Alignment of ZL_Error_s"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Error_s::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._info) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Error_s::_info"
    );
}
extern "C" {
    #[doc = " Actual implementation function which accepts all of the explicit arguments\n that are set up for you by the macros elsewhere. Prefer to use those macros\n rather than this function directly.\n - `file` arg is intended to be filled with __FILE__ macro.\n - `func` arg is intended to be filled with __func__ macro.\n - `line` arg is intended to be filled with __LINE__ macro."]
    pub fn ZL_E_create(
        st: *const ZL_StaticErrorInfo,
        ctx: *const ZL_ErrorContext,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        code: ZL_ErrorCode,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ZL_Error;
}
extern "C" {
    #[doc = " Append a formatted string to the error's message. May be a no-op if the\n error doesn't have a rich error info set up internally."]
    pub fn ZL_E_appendToMessage(err: ZL_Error, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Attempts to add more information to the error represented by @p error.\n Narrowly, this means trying to append a stack frame to the stacktrace that\n rich errors accumulate. In service of that, it also tries to up-convert the\n error to a rich error if it isn't already. @p fmt and optional additional\n following args can also be used to append an arbitrary formatted string of\n information into the error.\n\n This function can be called directly, but is primarily used indirectly.\n Firstly, if you want to invoke this function yourself, it's easier to use\n @ref ZL_E_ADDFRAME_PUBLIC instead since it populates some of the arguments\n for you. Secondly, this is an implementation detail mostly here to be used\n by @ref ZL_RET_T_IF_ERR and friends, which call this to add more context to\n the error as it passes by.\n\n @note OpenZL must have been compiled with ZL_ERROR_ENABLE_STACKS defined to\n       true for this to do anything. (This is the default.)\n\n @returns the modified error."]
    pub fn ZL_E_addFrame_public(
        ctx: *const ZL_ErrorContext,
        error: ZL_Error,
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ZL_Error;
}
#[doc = " ZL_Error_Array: a const view into an array of errors, returned by some\n public APIs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Error_Array {
    pub errors: *const ZL_Error,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_ZL_Error_Array() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Error_Array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Error_Array>(),
        16usize,
        "Size of ZL_Error_Array"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Error_Array>(),
        8usize,
        "Alignment of ZL_Error_Array"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errors) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Error_Array::errors"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Error_Array::size"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Result_ZL_GraphID_inner {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_GraphID,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_GraphID_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_GraphID_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_GraphID_inner>(),
        8usize,
        "Size of ZL_Result_ZL_GraphID_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_GraphID_inner>(),
        4usize,
        "Alignment of ZL_Result_ZL_GraphID_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphID_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_Result_ZL_GraphID_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_ZL_GraphID_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_ZL_GraphID_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_GraphID_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_GraphID_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_GraphID_u>(),
        16usize,
        "Size of ZL_Result_ZL_GraphID_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_GraphID_u>(),
        8usize,
        "Alignment of ZL_Result_ZL_GraphID_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphID_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphID_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphID_u::_error"
    );
}
pub type ZL_Result_ZL_GraphID = ZL_Result_ZL_GraphID_u;
extern "C" {
    #[link_name = "ZL_Result_ZL_GraphID_extract__extern"]
    pub fn ZL_Result_ZL_GraphID_extract(
        result: ZL_Result_ZL_GraphID,
        error: *mut ZL_Error,
    ) -> ZL_GraphID;
}
pub type ZL_Result_ZL_GraphID_fake_type_needs_semicolon = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Result_ZL_NodeID_inner {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_NodeID,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_NodeID_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_NodeID_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_NodeID_inner>(),
        8usize,
        "Size of ZL_Result_ZL_NodeID_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_NodeID_inner>(),
        4usize,
        "Alignment of ZL_Result_ZL_NodeID_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_NodeID_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_Result_ZL_NodeID_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_ZL_NodeID_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_ZL_NodeID_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_NodeID_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_NodeID_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_NodeID_u>(),
        16usize,
        "Size of ZL_Result_ZL_NodeID_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_NodeID_u>(),
        8usize,
        "Alignment of ZL_Result_ZL_NodeID_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_NodeID_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_NodeID_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_NodeID_u::_error"
    );
}
pub type ZL_Result_ZL_NodeID = ZL_Result_ZL_NodeID_u;
extern "C" {
    #[link_name = "ZL_Result_ZL_NodeID_extract__extern"]
    pub fn ZL_Result_ZL_NodeID_extract(
        result: ZL_Result_ZL_NodeID,
        error: *mut ZL_Error,
    ) -> ZL_NodeID;
}
pub type ZL_Result_ZL_NodeID_fake_type_needs_semicolon = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Result_size_t_inner {
    pub _code: ZL_ErrorCode,
    pub _value: usize,
}
#[test]
fn bindgen_test_layout_ZL_Result_size_t_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_size_t_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_size_t_inner>(),
        16usize,
        "Size of ZL_Result_size_t_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_size_t_inner>(),
        8usize,
        "Alignment of ZL_Result_size_t_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_size_t_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Result_size_t_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_size_t_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_size_t_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_size_t_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_size_t_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_size_t_u>(),
        16usize,
        "Size of ZL_Result_size_t_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_size_t_u>(),
        8usize,
        "Alignment of ZL_Result_size_t_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_size_t_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_size_t_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_size_t_u::_error"
    );
}
pub type ZL_Result_size_t = ZL_Result_size_t_u;
extern "C" {
    #[link_name = "ZL_Result_size_t_extract__extern"]
    pub fn ZL_Result_size_t_extract(result: ZL_Result_size_t, error: *mut ZL_Error) -> usize;
}
pub type ZL_Result_size_t_fake_type_needs_semicolon = ::std::os::raw::c_int;
pub type ZL_Report = ZL_Result_size_t;
extern "C" {
    #[doc = " @returns true iff the report contains an error"]
    #[link_name = "ZL_isError__extern"]
    pub fn ZL_isError(report: ZL_Report) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @pre !ZL_isError(report)\n @returns The value contained within the report"]
    #[link_name = "ZL_validResult__extern"]
    pub fn ZL_validResult(report: ZL_Report) -> usize;
}
extern "C" {
    #[doc = " @returns The error code contained within the report.\n If !ZL_isError(report), then @returns ZL_ErrorCode_no_error."]
    #[link_name = "ZL_errorCode__extern"]
    pub fn ZL_errorCode(report: ZL_Report) -> ZL_ErrorCode;
}
extern "C" {
    pub fn ZL_ErrorCode_toString(code: ZL_ErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns a successful report containing a value."]
    #[link_name = "ZL_returnValue__extern"]
    pub fn ZL_returnValue(s: usize) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns a successful report without a value (set to zero)."]
    #[link_name = "ZL_returnSuccess__extern"]
    pub fn ZL_returnSuccess() -> ZL_Report;
}
extern "C" {
    #[doc = " @returns a specific ZL_ErrorCode as a ZL_Report return type."]
    pub fn ZL_returnError(err: ZL_ErrorCode) -> ZL_Report;
}
extern "C" {
    pub fn ZL_reportError(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        err: ZL_ErrorCode,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ZL_Report;
}
pub const ZL_Type_serial: ZL_Type = 1;
pub const ZL_Type_struct: ZL_Type = 2;
pub const ZL_Type_numeric: ZL_Type = 4;
pub const ZL_Type_string: ZL_Type = 8;
#[doc = " Any Data object has necessary a Type.\n The least specific Type is `ZL_Type_serial`,\n which means it's just a blob of bytes.\n Codecs can only accept and produce specified data Types.\n In contrast, Selectors & Graphs may optionally accept multiple data Types,\n using bitmap masking (example: `ZL_Type_struct | ZL_Type_numeric`)."]
pub type ZL_Type = ::std::os::raw::c_uint;
pub const ZL_DataArenaType_heap: ZL_DataArenaType = 0;
pub const ZL_DataArenaType_stack: ZL_DataArenaType = 1;
pub type ZL_DataArenaType = ::std::os::raw::c_uint;
extern "C" {
    pub fn ZL_Data_id(in_: *const ZL_Data) -> ZL_DataID;
}
extern "C" {
    pub fn ZL_Data_type(data: *const ZL_Data) -> ZL_Type;
}
extern "C" {
    #[doc = " @note invoking `ZL_Data_numElts()` is only valid for committed Data.\n If the Data object was received as an input, it's necessarily valid.\n So the issue can only happen for outputs,\n between allocation and commit.\n Querying `ZL_Data_numElts()` is not expected to be useful for output Data.\n @note `ZL_Type_serial` doesn't really have a concept of \"elt\".\n In this case, it returns Data size in bytes."]
    pub fn ZL_Data_numElts(data: *const ZL_Data) -> usize;
}
extern "C" {
    #[doc = " @return element width in nb of bytes\n This is only valid for fixed size elements,\n such as `ZL_Type_struct` or `ZL_Type_numeric`.\n If Type is `ZL_Type_string`, it returns 0 instead."]
    pub fn ZL_Data_eltWidth(data: *const ZL_Data) -> usize;
}
extern "C" {
    #[doc = " @return the nb of bytes committed into data's buffer\n (generally `== data->eltWidth * data->nbElts`).\n\n For `ZL_Type_string`, result is equal to `sum(data->stringLens)`.\n Returned value is provided in nb of bytes.\n\n @note invoking this symbol only makes sense if Data was\n previously committed.\n @note (@cyan): ZS2_Data_byteSize() is another name candidate."]
    pub fn ZL_Data_contentSize(data: *const ZL_Data) -> usize;
}
extern "C" {
    #[doc = " These methods provide direct access to internal buffer.\n Warning : users must pay attention to buffer boundaries.\n @return pointer to the _beginning_ of buffer.\n @note for `ZL_Type_string`, returns a pointer to the buffer containing the\n concatenated strings."]
    pub fn ZL_Data_rPtr(data: *const ZL_Data) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_Data_wPtr(data: *mut ZL_Data) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n @return a pointer to the array of string lengths.\n The size of this array is `== ZL_Data_numElts(data)`.\n @return `NULL` if incorrect data type, or `StringLens` not allocated yet."]
    pub fn ZL_Data_rStringLens(data: *const ZL_Data) -> *const u32;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n It requires write access into StringLens array.\n Only valid if StringLens array has already been allocated\n and not yet written into.\n @return NULL when any of the above conditions is violated.\n\n Array's capacity is supposed known from reservation request.\n After writing into the array, the nb of Strings, which is also\n the nb of String Lengths written, must be provided using\n ZL_Data_commit()."]
    pub fn ZL_Data_wStringLens(data: *mut ZL_Data) -> *mut u32;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n It reserves memory space for StringLens array, and returns a pointer to it.\n The buffer is owned by @p data and has the same lifetime.\n The returned pointer can be used to write into the array.\n After writing into the array, the nb of String Lengths provided must be\n signaled using @ref ZL_Data_commit().\n This method will fail if StringLens is already allocated.\n @return `NULL` if incorrect data type, or allocation error."]
    pub fn ZL_Data_reserveStringLens(data: *mut ZL_Data, nbStrings: usize) -> *mut u32;
}
extern "C" {
    #[doc = " @brief Commit the number of elements written into @p data.\n\n This method must be called exactly once for every output.\n The @p nbElts must be `<=` reserved capacity of @p data.\n Note that, for `ZL_Type_string`, this is the number of strings written into\n@p data.\n The operation will automatically determine the total size of all Strings\nwithin @p data.\n\n @returns Success or an error. This function will fail if it is called more\n than once on the same @p data, or if @p nbElts is greater than @p data's\n capacity.\n\n Terminating a Codec _without_ committing anything to @p data (not even `0`)\n is considered an error, that is caught by the Engine\n (classified as node processing error).\n\n @note @p nbElts, as \"number of elements\", is **not** the same as size in\nbytes written in\n the buffer. For Numerics and Structs, the translation is\n straighforward. For Strings, the field sizes array must be\n provided first, using `ZL_Data_reserveStringLens()` to create\n and access the array. The resulting useful content size will then\n be calculated from the sum of field sizes. It will be controlled,\n and there will be an error if sum(sizes) > bufferCapacity."]
    pub fn ZL_Data_commit(data: *mut ZL_Data, nbElts: usize) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Sets integer metadata with the key @p mId and value @p mvalue on the\n stream.\n\n It is only valid to call ZL_Data_setIntMetadata() with the same @p mId\n once. Subsequent calls with the same @p mId will return an error.\n\n @param mId Metdata key\n @param mvalue Metadata value\n\n @returns Success or an error. This function will fail due to repeated calls\n with the same @p mId, or upon running out of space for the metadata.\n\n @note In this proposed design, Int Metadata are set one by one.\n Another possible design could follow the IntParams\n model, where all parameters must be set all-at-once, and be\n provided as a single vector of IntParams structures.\n\n @note The set value is an int, hence it's not suitable to store \"large\"\n values, like 64-bit ULL."]
    pub fn ZL_Data_setIntMetadata(
        s: *mut ZL_Data,
        mId: ::std::os::raw::c_int,
        mvalue: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_IntMetadata {
    pub isPresent: ::std::os::raw::c_int,
    pub mValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ZL_IntMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_IntMetadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_IntMetadata>(),
        8usize,
        "Size of ZL_IntMetadata"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_IntMetadata>(),
        4usize,
        "Alignment of ZL_IntMetadata"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isPresent) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_IntMetadata::isPresent"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mValue) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_IntMetadata::mValue"
    );
}
extern "C" {
    pub fn ZL_Data_getIntMetadata(s: *const ZL_Data, mId: ::std::os::raw::c_int) -> ZL_IntMetadata;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_IntParam {
    pub paramId: ::std::os::raw::c_int,
    pub paramValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ZL_IntParam() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_IntParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_IntParam>(),
        8usize,
        "Size of ZL_IntParam"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_IntParam>(),
        4usize,
        "Alignment of ZL_IntParam"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramId) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_IntParam::paramId"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramValue) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_IntParam::paramValue"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_LocalIntParams {
    pub intParams: *const ZL_IntParam,
    pub nbIntParams: usize,
}
#[test]
fn bindgen_test_layout_ZL_LocalIntParams() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_LocalIntParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_LocalIntParams>(),
        16usize,
        "Size of ZL_LocalIntParams"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_LocalIntParams>(),
        8usize,
        "Alignment of ZL_LocalIntParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intParams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_LocalIntParams::intParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbIntParams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_LocalIntParams::nbIntParams"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CopyParam {
    pub paramId: ::std::os::raw::c_int,
    pub paramPtr: *const ::std::os::raw::c_void,
    pub paramSize: usize,
}
#[test]
fn bindgen_test_layout_ZL_CopyParam() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_CopyParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_CopyParam>(),
        24usize,
        "Size of ZL_CopyParam"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_CopyParam>(),
        8usize,
        "Alignment of ZL_CopyParam"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramId) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_CopyParam::paramId"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramPtr) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_CopyParam::paramPtr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramSize) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_CopyParam::paramSize"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_LocalCopyParams {
    pub copyParams: *const ZL_CopyParam,
    pub nbCopyParams: usize,
}
#[test]
fn bindgen_test_layout_ZL_LocalCopyParams() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_LocalCopyParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_LocalCopyParams>(),
        16usize,
        "Size of ZL_LocalCopyParams"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_LocalCopyParams>(),
        8usize,
        "Alignment of ZL_LocalCopyParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyParams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_LocalCopyParams::copyParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCopyParams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_LocalCopyParams::nbCopyParams"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_RefParam {
    pub paramId: ::std::os::raw::c_int,
    pub paramRef: *const ::std::os::raw::c_void,
    #[doc = " Optionally the size of the referenced object.\n OpenZL does not interpret this value. A common pattern is to use the\n value 0 to mean unknown size."]
    pub paramSize: usize,
}
#[test]
fn bindgen_test_layout_ZL_RefParam() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_RefParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_RefParam>(),
        24usize,
        "Size of ZL_RefParam"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_RefParam>(),
        8usize,
        "Alignment of ZL_RefParam"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramId) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_RefParam::paramId"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramRef) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_RefParam::paramRef"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramSize) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_RefParam::paramSize"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_LocalRefParams {
    pub refParams: *const ZL_RefParam,
    pub nbRefParams: usize,
}
#[test]
fn bindgen_test_layout_ZL_LocalRefParams() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_LocalRefParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_LocalRefParams>(),
        16usize,
        "Size of ZL_LocalRefParams"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_LocalRefParams>(),
        8usize,
        "Alignment of ZL_LocalRefParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refParams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_LocalRefParams::refParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbRefParams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_LocalRefParams::nbRefParams"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_LocalParams {
    pub intParams: ZL_LocalIntParams,
    pub copyParams: ZL_LocalCopyParams,
    pub refParams: ZL_LocalRefParams,
}
#[test]
fn bindgen_test_layout_ZL_LocalParams() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_LocalParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_LocalParams>(),
        48usize,
        "Size of ZL_LocalParams"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_LocalParams>(),
        8usize,
        "Alignment of ZL_LocalParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intParams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_LocalParams::intParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyParams) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_LocalParams::copyParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refParams) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_LocalParams::refParams"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CompressIntrospectionHooks_s {
    pub opaque: *mut ::std::os::raw::c_void,
    pub on_ZL_Encoder_getScratchSpace: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, ei: *mut ZL_Encoder, size: usize),
    >,
    pub on_ZL_Encoder_sendCodecHeader: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            eictx: *mut ZL_Encoder,
            trh: *const ::std::os::raw::c_void,
            trhSize: usize,
        ),
    >,
    pub on_ZL_Encoder_createTypedStream: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            eic: *mut ZL_Encoder,
            outStreamIndex: ::std::os::raw::c_int,
            eltsCapacity: usize,
            eltWidth: usize,
            createdStream: *mut ZL_Output,
        ),
    >,
    pub on_ZL_Graph_getScratchSpace: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, gctx: *mut ZL_Graph, size: usize),
    >,
    pub on_ZL_Edge_setMultiInputDestination_wParams: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            gctx: *mut ZL_Graph,
            inputs: *mut *mut ZL_Edge,
            nbInputs: usize,
            gid: ZL_GraphID,
            lparams: *const ZL_LocalParams,
        ),
    >,
    pub on_migraphEncode_start: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            gctx: *mut ZL_Graph,
            compressor: *const ZL_Compressor,
            gid: ZL_GraphID,
            inputs: *mut *mut ZL_Edge,
            nbInputs: usize,
        ),
    >,
    pub on_migraphEncode_end: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            arg1: *mut ZL_Graph,
            successorGraphs: *mut ZL_GraphID,
            nbSuccessors: usize,
            graphExecResult: ZL_Report,
        ),
    >,
    pub on_codecEncode_start: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            eictx: *mut ZL_Encoder,
            compressor: *const ZL_Compressor,
            nid: ZL_NodeID,
            inStreams: *mut *const ZL_Input,
            nbInStreams: usize,
        ),
    >,
    pub on_codecEncode_end: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            arg1: *mut ZL_Encoder,
            outStreams: *mut *const ZL_Output,
            nbOutputs: usize,
            codecExecResult: ZL_Report,
        ),
    >,
    pub on_cctx_convertOneInput: ::std::option::Option<
        unsafe extern "C" fn(
            opque: *mut ::std::os::raw::c_void,
            cctx: *const ZL_CCtx,
            input: *const ZL_Data,
            inType: ZL_Type,
            portTypeMask: ZL_Type,
            conversionResult: ZL_Report,
        ),
    >,
    pub on_ZL_CCtx_compressMultiTypedRef_start: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            cctx: *const ZL_CCtx,
            dst: *const ::std::os::raw::c_void,
            dstCapacity: usize,
            inputs: *const *const ZL_TypedRef,
            nbInputs: usize,
        ),
    >,
    pub on_ZL_CCtx_compressMultiTypedRef_end: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut ::std::os::raw::c_void,
            cctx: *const ZL_CCtx,
            result: ZL_Report,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ZL_CompressIntrospectionHooks_s() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_CompressIntrospectionHooks_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_CompressIntrospectionHooks_s>(),
        104usize,
        "Size of ZL_CompressIntrospectionHooks_s"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_CompressIntrospectionHooks_s>(),
        8usize,
        "Alignment of ZL_CompressIntrospectionHooks_s"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::opaque"
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_ZL_Encoder_getScratchSpace) as usize - ptr as usize
        },
        8usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_Encoder_getScratchSpace"
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_ZL_Encoder_sendCodecHeader) as usize - ptr as usize
        },
        16usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_Encoder_sendCodecHeader"
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_ZL_Encoder_createTypedStream) as usize - ptr as usize
        },
        24usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_Encoder_createTypedStream"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_ZL_Graph_getScratchSpace) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_Graph_getScratchSpace"
    );
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . on_ZL_Edge_setMultiInputDestination_wParams) as usize - ptr as usize } , 40usize , "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_Edge_setMultiInputDestination_wParams");
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_migraphEncode_start) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_migraphEncode_start"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_migraphEncode_end) as usize - ptr as usize },
        56usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_migraphEncode_end"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_codecEncode_start) as usize - ptr as usize },
        64usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_codecEncode_start"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_codecEncode_end) as usize - ptr as usize },
        72usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_codecEncode_end"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_cctx_convertOneInput) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_cctx_convertOneInput"
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_ZL_CCtx_compressMultiTypedRef_start) as usize
                - ptr as usize
        },
        88usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_CCtx_compressMultiTypedRef_start"
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_ZL_CCtx_compressMultiTypedRef_end) as usize
                - ptr as usize
        },
        96usize,
        "Offset of field: ZL_CompressIntrospectionHooks_s::on_ZL_CCtx_compressMultiTypedRef_end"
    );
}
pub type ZL_CompressIntrospectionHooks = ZL_CompressIntrospectionHooks_s;
extern "C" {
    #[doc = " @returns The current encoding version number.\n This version number is used when the version\n number is unset.\n\n To use a fixed version number for encoding,\n grab the current version number using this\n function, and then pass it as a constant to\n ZL_CParam_formatVersion.\n\n NOTE: We currently only offer the ability to\n encode with older versions for a very limited\n period, so a new release will eventually\n remove support for encoding with any fixed\n version number. If you need long term\n support for a version, please reach out to\n the data_compression team, since that isn't\n currently supported."]
    pub fn ZL_getDefaultEncodingVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Reads the magic number from the frame and returns the\n format version.\n\n @returns The format version of the frame, or an error\n if the frame isn't large enough, or it has the wrong\n magic number, or if the format version is not supported."]
    pub fn ZL_getFormatVersionFromFrame(
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Provides the upper bound for the compressed size needed to ensure\n that compressing @p totalSrcSize is successful. When compressing\n multiple inputs, @p totalSrcSize must be the sum of the size of each input.\n\n @param totalSrcSize The sum of all input sizes\n @returns The upper bound of the compressed size\n\n @note This is a very large over-estimation, to be tightened later"]
    #[link_name = "ZL_compressBound__extern"]
    pub fn ZL_compressBound(totalSrcSize: usize) -> usize;
}
extern "C" {
    pub fn ZL_CCtx_create() -> *mut ZL_CCtx;
}
extern "C" {
    pub fn ZL_CCtx_free(cctx: *mut ZL_CCtx);
}
#[doc = " Only meaningful at CCtx level (ignored at CGraph level)\n By default, parameters are reset between compression sessions\n setting this parameter to 1 keep the parameters across compression\n sessions."]
pub const ZL_CParam_stickyParameters: ZL_CParam = 1;
#[doc = " Scale amplitude to determine"]
pub const ZL_CParam_compressionLevel: ZL_CParam = 2;
#[doc = " Scale amplitude to determine"]
pub const ZL_CParam_decompressionLevel: ZL_CParam = 3;
#[doc = " Sets the format version number to use for encoding.\n See @ZL_getDefaultEncodingVersion for details.\n @default 0 means use format version ZL_getDefaultEncodingVersion()."]
pub const ZL_CParam_formatVersion: ZL_CParam = 4;
#[doc = " Select behavior when an internal compression stage fails.\n For example, when expecting an array of 32-bit integers,\n but the input size is not a clean multiple of 4.\n Strict mode stops at such stage and outputs an error.\n Permissive mode engages a generic backup compression mechanism,\n to successfully complete compression, at the cost of efficiency.\n At the time of this writing, backup is ZL_GRAPH_COMPRESS_GENERIC.\n Valid values for this parameter use the ZS2_cv3_* format.\n @default 0 currently means strict mode. This may change in the\n future."]
pub const ZL_CParam_permissiveCompression: ZL_CParam = 5;
#[doc = " Enable checksum of the compressed frame.\n This is useful to check for corruption that happens after\n compression.\n Valid values for this parameter use the ZS2_cv3_* format.\n @default 0 currently means checksum, might change in the future."]
pub const ZL_CParam_compressedChecksum: ZL_CParam = 6;
#[doc = " Enable checksum of the uncompressed content contained in the frame.\n This is useful to check for corruption that happens after\n compression,\n or corruption introduced during (de)compression. However, it cannot\n distinguish the two alone. In order to determine whether it is\n corruption or a bug in the ZStrong library, you have to enable both\n compressed and content checksums.\n Valid values for this parameter use the ZS2_cv3_* format.\n @default 0 currently means checksum, might change in the future."]
pub const ZL_CParam_contentChecksum: ZL_CParam = 7;
#[doc = " Any time an internal data Stream becomes smaller than this size,\n it gets STORED immediately, without further processing.\n This reduces processing time, improves decompression speed, and\n reduce\n risks of data expansion.\n Note(@Cyan): follows convention that setting 0 means \"default\", aka\n ZL_MINSTREAMSIZE_DEFAULT.\n Therefore, in order to completely disable the \"automatic store\"\n feature,\n one must pass a negative threshold value."]
pub const ZL_CParam_minStreamSize: ZL_CParam = 11;
#[doc = " The list of global compression parameters"]
pub type ZL_CParam = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Sets a global compression parameter via the CCtx.\n\n @param gcparam The global compression parameter to set\n @param value The value to set the global compression parameter to\n @returns A ZL_Report containing the result of the operation\n\n @note Parameters set via CCtx have higher priority than parameters set via\n CGraph.\n @note By default, parameters set via CCtx are reset at the end of the\n compression session. To preserve them across sessions, set\n stickyParameters=1."]
    pub fn ZL_CCtx_setParameter(
        cctx: *mut ZL_CCtx,
        gcparam: ZL_CParam,
        value: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Reads a compression parameter's configured value from the CCtx.\n\n @param gcparam The global compression parameter to read\n @returns The value set for the given parameter (0 if unset or does not\n exist)"]
    pub fn ZL_CCtx_getParameter(cctx: *const ZL_CCtx, gcparam: ZL_CParam) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Resets the parameters in the cctx to a blank state.\n\n @note Useful when unsure if ZL_CParam_stickyParameters is set to 1."]
    pub fn ZL_CCtx_resetParameters(cctx: *mut ZL_CCtx) -> ZL_Report;
}
extern "C" {
    #[doc = " Sets the Arena for Data* objects in the CCtx.\n This frees the previous Data Arena and creates a new one.\n This choice remains sticky, until set again.\n The default Data Arena is HeapArena.\n\n @param sat The Data Arena type to set\n\n @note This is an advanced (experimental) parameter."]
    pub fn ZL_CCtx_setDataArena(cctx: *mut ZL_CCtx, sat: ZL_DataArenaType) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief A one-shot (blocking) compression function.\n\n @param dst The destination buffer to write the compressed data to\n @param dstCapacity The capacity of the destination buffer\n @param src The source buffer to compress\n @param srcSize The size of the source buffer\n\n @returns The number of bytes written into @p dst, if successful. Otherwise,\n returns an error."]
    pub fn ZL_CCtx_compress(
        cctx: *mut ZL_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Gets the error context for a given ZL_Report. This context is useful for\n debugging and for submitting bug reports to Zstrong developers.\n\n @param report The report to get the error context for\n\n @returns A verbose error string containing context about the error that\n occurred.\n\n @note: This string is stored within the @p cctx and is only valid for the\n lifetime of the @p cctx."]
    pub fn ZL_CCtx_getErrorContextString(
        cctx: *const ZL_CCtx,
        report: ZL_Report,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " See ZL_CCtx_getErrorContextString()\n\n @param error: The error to get the context for"]
    pub fn ZL_CCtx_getErrorContextString_fromError(
        cctx: *const ZL_CCtx,
        error: ZL_Error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the warnings that were encountered during the lifetime of the\n most recent compression operation.\n\n @returns The array of warnings encountered\n\n @note The array's and the errors' lifetimes are valid until the next\n compression operation."]
    pub fn ZL_CCtx_getWarnings(cctx: *const ZL_CCtx) -> ZL_Error_Array;
}
extern "C" {
    #[doc = " @brief Attach introspection hooks to the CCtx.\n\n The supplied functions in @p hooks will be called at specified waypoints\n during compression. These functions are expected to be pure observer\n functions only. Attempts to modify the intermediate structures exposed at\n these waypoints will almost certainly cause data corruption!\n\n @note This copies the content of the hooks struct into the CCtx. The caller\n is responsible for maintaining the lifetime of the objects in the hook.\n\n @note This will only do something if the library is compiled with the\n ALLOW_INTROSPECTION option. Otherwise, all the hooks will be no-ops."]
    pub fn ZL_CCtx_attachIntrospectionHooks(
        cctx: *mut ZL_CCtx,
        hooks: *const ZL_CompressIntrospectionHooks,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Detach any introspection hooks currently attached to the CCtx."]
    pub fn ZL_CCtx_detachAllIntrospectionHooks(cctx: *mut ZL_CCtx) -> ZL_Report;
}
extern "C" {
    #[doc = " Compresses a single typed input presented as a\n `ZL_TypedRef`. See below for TypedRef* object creation.\n\n @param dst The destination buffer to write the compressed data to\n @param dstCapacity The capacity of the destination buffer\n @param input: The input to compress\n\n @returns The number of bytes written into @p dst, if successful. Otherwise,\n returns an error."]
    pub fn ZL_CCtx_compressTypedRef(
        cctx: *mut ZL_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        input: *const ZL_TypedRef,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Compresses multiple typed inputs , presented as an\n array of `ZL_TypedRef`. See below for TypedRef* object creation.\n\n @param dst The destination buffer to write the compressed data to\n @param dstCapacity The capacity of the destination buffer\n @param inputs: The inputs to compress\n @param nbInputs: The number of inputs to compress\n\n @returns The number of bytes written into @p dst, if successful. Otherwise,\n returns an error.\n\n @note These inputs will be regenerated together in the same order at\n decompression time."]
    pub fn ZL_CCtx_compressMultiTypedRef(
        cctx: *mut ZL_CCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        inputs: *mut *const ZL_TypedRef,
        nbInputs: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Creates a `ZL_TypedRef` that represents a regular buffer of bytes.\n\n @param src The reference buffer\n @param srcSize The size of the reference buffer\n\n @returns A `ZL_TypedRef*` of type `ZL_Type_serial`."]
    pub fn ZL_TypedRef_createSerial(
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> *mut ZL_TypedRef;
}
extern "C" {
    #[doc = " Creates a `ZL_TypedRef` that represents a concatenated list of fields of a\n fixed size of @p structWidth.\n\n @p structWidth can be any size > 0. Even odd sizes (13, 17, etc.) are\n allowed. All fields are considered concatenated back to back. There is no\n alignment requirement.\n\n @param start The start of the reference buffer\n @param structWidth The width of each element in the reference buffer.\n @param structCount The number of elements in the input buffer. The total\n size will be @p structWidth * @p structCount.\n\n @note Struct in this case is just short-hand for fixed-size-fields. It's\n not limited to C-style structures."]
    pub fn ZL_TypedRef_createStruct(
        start: *const ::std::os::raw::c_void,
        structWidth: usize,
        structCount: usize,
    ) -> *mut ZL_TypedRef;
}
extern "C" {
    #[doc = " Creates a `ZL_TypedRef` that references an array of numeric values,\n employing the local host's endianness.\n Supported widths are 1, 2, 4, and 8 and the input array must be properly\n aligned (in local ABI).\n\n @param start The start of the reference array\n @param numWidth The width of the numeric values\n @param numCount The number of elements in the input array. The total size\n will be @p numWidth * @p numCount.\n"]
    pub fn ZL_TypedRef_createNumeric(
        start: *const ::std::os::raw::c_void,
        numWidth: usize,
        numCount: usize,
    ) -> *mut ZL_TypedRef;
}
extern "C" {
    #[doc = " Creates a `ZL_TypedRef` referencing a \"flat-strings\" representation. All\n \"strings\" are concatenated into @p strBuffer and their lengths are stored in\n a @p strLens array.\n\n @param strBuffer The data buffer\n @param bufferSize The size of the data buffer\n @param strLengths The lengths array\n @param nbStrings The number of strings (i.e. the size of the lengths array)\n\n @note String is just short-hand for variable-size-fields. It's not limited\n to null-terminated ascii strings. A string can be any blob of bytes,\n including some containing 0-value bytes, because length is explicit."]
    pub fn ZL_TypedRef_createString(
        strBuffer: *const ::std::os::raw::c_void,
        bufferSize: usize,
        strLens: *const u32,
        nbStrings: usize,
    ) -> *mut ZL_TypedRef;
}
extern "C" {
    #[doc = " Frees the given `ZL_TypedRef`.\n\n @param tref the object to free\n\n @note All ZL_TypedRef* objects of any type are released by the same method"]
    pub fn ZL_TypedRef_free(tref: *mut ZL_TypedRef);
}
extern "C" {
    #[doc = " Inserts a placeholder for the Automated Compressor Explorer (ACE) to\n replace with an automatically generated graph. It accepts a single input of\n any type.\n\n Before training, this graph will just forward to `ZL_GRAPH_COMPRESS_GENERIC`.\n After training the top-level graph, ACE will replace this component with an\n automatically generated graph that performs well on the training data.\n\n If the same ACE GraphID is used multiple times within a graph, all the inputs\n get passed to the same training, and only a single graph is generated. If\n there are multiple ACE graphs in a top-level graph, each created with a call\n to `ZL_Compressor_buildACEGraph()`, then each unique GraphID will be replaced\n with a trained graph optimized for the inputs passed to that specific\n GraphID.\n\n Input 0: Any type\n\n @returns The placeholder ACE graphID."]
    pub fn ZL_Compressor_buildACEGraph(compressor: *mut ZL_Compressor) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @see ZL_Compressor_buildACEGraph"]
    pub fn ZL_Compressor_buildACEGraph2(compressor: *mut ZL_Compressor) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    #[doc = " The same as `ZL_Compressor_buildACEGraph`, but uses `defaultGraph` to\n compress until it is trained.\n\n @see ZL_Compressor_buildACEGraph"]
    pub fn ZL_Compressor_buildACEGraphWithDefault(
        compressor: *mut ZL_Compressor,
        defaultGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @see ZL_Compressor_buildACEGraphWithDefault"]
    pub fn ZL_Compressor_buildACEGraphWithDefault2(
        compressor: *mut ZL_Compressor,
        defaultGraph: ZL_GraphID,
    ) -> ZL_Result_ZL_GraphID;
}
pub const ZL_StandardGraphID_illegal: ZL_StandardGraphID = 0;
pub const ZL_StandardGraphID_store: ZL_StandardGraphID = 2;
pub const ZL_StandardGraphID_fse: ZL_StandardGraphID = 3;
pub const ZL_StandardGraphID_huffman: ZL_StandardGraphID = 4;
pub const ZL_StandardGraphID_entropy: ZL_StandardGraphID = 5;
pub const ZL_StandardGraphID_constant: ZL_StandardGraphID = 6;
pub const ZL_StandardGraphID_zstd: ZL_StandardGraphID = 7;
pub const ZL_StandardGraphID_bitpack: ZL_StandardGraphID = 8;
pub const ZL_StandardGraphID_flatpack: ZL_StandardGraphID = 9;
pub const ZL_StandardGraphID_field_lz: ZL_StandardGraphID = 10;
pub const ZL_StandardGraphID_compress_generic: ZL_StandardGraphID = 11;
pub const ZL_StandardGraphID_select_generic_lz_backend: ZL_StandardGraphID = 12;
pub const ZL_StandardGraphID_select_numeric: ZL_StandardGraphID = 13;
pub const ZL_StandardGraphID_clustering: ZL_StandardGraphID = 14;
pub const ZL_StandardGraphID_try_parse_int: ZL_StandardGraphID = 15;
pub const ZL_StandardGraphID_simple_data_description_language: ZL_StandardGraphID = 16;
pub const ZL_StandardGraphID_public_end: ZL_StandardGraphID = 17;
pub type ZL_StandardGraphID = ::std::os::raw::c_uint;
pub const ZL_StandardNodeID_illegal: ZL_StandardNodeID = 0;
pub const ZL_StandardNodeID_delta_int: ZL_StandardNodeID = 2;
pub const ZL_StandardNodeID_transpose_split: ZL_StandardNodeID = 3;
pub const ZL_StandardNodeID_zigzag: ZL_StandardNodeID = 4;
pub const ZL_StandardNodeID_dispatchN_byTag: ZL_StandardNodeID = 5;
pub const ZL_StandardNodeID_float32_deconstruct: ZL_StandardNodeID = 6;
pub const ZL_StandardNodeID_bfloat16_deconstruct: ZL_StandardNodeID = 7;
pub const ZL_StandardNodeID_float16_deconstruct: ZL_StandardNodeID = 8;
pub const ZL_StandardNodeID_field_lz: ZL_StandardNodeID = 9;
pub const ZL_StandardNodeID_convert_struct_to_serial: ZL_StandardNodeID = 10;
pub const ZL_StandardNodeID_convert_num_to_struct_le: ZL_StandardNodeID = 11;
pub const ZL_StandardNodeID_convert_num_to_serial_le: ZL_StandardNodeID = 12;
pub const ZL_StandardNodeID_convert_serial_to_struct: ZL_StandardNodeID = 13;
pub const ZL_StandardNodeID_convert_serial_to_struct2: ZL_StandardNodeID = 14;
pub const ZL_StandardNodeID_convert_serial_to_struct4: ZL_StandardNodeID = 15;
pub const ZL_StandardNodeID_convert_serial_to_struct8: ZL_StandardNodeID = 16;
pub const ZL_StandardNodeID_convert_struct_to_num_le: ZL_StandardNodeID = 17;
pub const ZL_StandardNodeID_convert_struct_to_num_be: ZL_StandardNodeID = 18;
pub const ZL_StandardNodeID_convert_serial_to_num8: ZL_StandardNodeID = 19;
pub const ZL_StandardNodeID_convert_serial_to_num_le16: ZL_StandardNodeID = 20;
pub const ZL_StandardNodeID_convert_serial_to_num_le32: ZL_StandardNodeID = 21;
pub const ZL_StandardNodeID_convert_serial_to_num_le64: ZL_StandardNodeID = 22;
pub const ZL_StandardNodeID_convert_serial_to_num_be16: ZL_StandardNodeID = 23;
pub const ZL_StandardNodeID_convert_serial_to_num_be32: ZL_StandardNodeID = 24;
pub const ZL_StandardNodeID_convert_serial_to_num_be64: ZL_StandardNodeID = 25;
pub const ZL_StandardNodeID_separate_string_components: ZL_StandardNodeID = 26;
pub const ZL_StandardNodeID_bitunpack: ZL_StandardNodeID = 27;
pub const ZL_StandardNodeID_range_pack: ZL_StandardNodeID = 28;
pub const ZL_StandardNodeID_merge_sorted: ZL_StandardNodeID = 29;
pub const ZL_StandardNodeID_prefix: ZL_StandardNodeID = 30;
pub const ZL_StandardNodeID_divide_by: ZL_StandardNodeID = 31;
pub const ZL_StandardNodeID_dispatch_string: ZL_StandardNodeID = 32;
pub const ZL_StandardNodeID_concat_serial: ZL_StandardNodeID = 33;
pub const ZL_StandardNodeID_concat_num: ZL_StandardNodeID = 34;
pub const ZL_StandardNodeID_concat_struct: ZL_StandardNodeID = 35;
pub const ZL_StandardNodeID_concat_string: ZL_StandardNodeID = 36;
pub const ZL_StandardNodeID_dedup_num: ZL_StandardNodeID = 37;
pub const ZL_StandardNodeID_parse_int: ZL_StandardNodeID = 38;
pub const ZL_StandardNodeID_interleave_string: ZL_StandardNodeID = 39;
pub const ZL_StandardNodeID_tokenize_struct: ZL_StandardNodeID = 40;
pub const ZL_StandardNodeID_tokenize_numeric: ZL_StandardNodeID = 41;
pub const ZL_StandardNodeID_tokenize_string: ZL_StandardNodeID = 42;
pub const ZL_StandardNodeID_quantize_offsets: ZL_StandardNodeID = 43;
pub const ZL_StandardNodeID_quantize_lengths: ZL_StandardNodeID = 44;
pub const ZL_StandardNodeID_public_end: ZL_StandardNodeID = 45;
pub type ZL_StandardNodeID = ::std::os::raw::c_uint;
pub const ZL_Bitunpack_numBits: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn ZL_Compressor_registerBitunpackNode(
        cgraph: *mut ZL_Compressor,
        nbBits: ::std::os::raw::c_int,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Parameterized brute force selector that selects the best successor from a\n user-provided list of candidates.\n @param successors the list of successors to select from. Each successor must\n be equipped to handle the input stream type."]
    pub fn ZL_Compressor_registerBruteForceSelectorGraph(
        cgraph: *mut ZL_Compressor,
        successors: *const ZL_GraphID,
        numSuccessors: usize,
    ) -> ZL_GraphID;
}
extern "C" {
    #[link_name = "ZL_codemodInputAsData__extern"]
    pub fn ZL_codemodInputAsData(input: *const ZL_Input) -> *const ZL_Data;
}
extern "C" {
    #[link_name = "ZL_codemodDataAsInput__extern"]
    pub fn ZL_codemodDataAsInput(data: *const ZL_Data) -> *const ZL_Input;
}
extern "C" {
    #[link_name = "ZL_codemodMutInputAsData__extern"]
    pub fn ZL_codemodMutInputAsData(input: *mut ZL_Input) -> *mut ZL_Data;
}
extern "C" {
    #[link_name = "ZL_codemodMutDataAsInput__extern"]
    pub fn ZL_codemodMutDataAsInput(data: *mut ZL_Data) -> *mut ZL_Input;
}
extern "C" {
    #[link_name = "ZL_codemodDatasAsInputs__extern"]
    pub fn ZL_codemodDatasAsInputs(datas: *mut *const ZL_Data) -> *mut *const ZL_Input;
}
extern "C" {
    #[link_name = "ZL_codemodInputsAsDatas__extern"]
    pub fn ZL_codemodInputsAsDatas(inputs: *mut *const ZL_Input) -> *mut *const ZL_Data;
}
extern "C" {
    #[link_name = "ZL_Input_id__extern"]
    pub fn ZL_Input_id(input: *const ZL_Input) -> ZL_DataID;
}
extern "C" {
    #[link_name = "ZL_Input_type__extern"]
    pub fn ZL_Input_type(input: *const ZL_Input) -> ZL_Type;
}
extern "C" {
    #[doc = " @note invoking `ZL_Data_numElts()` is only valid for committed Data.\n If the Data object was received as an input, it's necessarily valid.\n So the issue can only happen for outputs,\n between allocation and commit.\n Querying `ZL_Data_numElts()` is not expected to be useful for output Data.\n @note `ZL_Type_serial` doesn't really have a concept of \"elt\".\n In this case, it returns Data size in bytes."]
    #[link_name = "ZL_Input_numElts__extern"]
    pub fn ZL_Input_numElts(input: *const ZL_Input) -> usize;
}
extern "C" {
    #[doc = " @return element width in nb of bytes\n This is only valid for fixed size elements,\n such as `ZL_Type_struct` or `ZL_Type_numeric`.\n If Type is `ZL_Type_string`, it returns 0 instead."]
    #[link_name = "ZL_Input_eltWidth__extern"]
    pub fn ZL_Input_eltWidth(input: *const ZL_Input) -> usize;
}
extern "C" {
    #[doc = " @return the nb of bytes committed into data's buffer\n (generally `== data->eltWidth * data->nbElts`).\n\n For `ZL_Type_string`, result is equal to `sum(data->stringLens)`.\n Returned value is provided in nb of bytes.\n\n @note invoking this symbol only makes sense if Data was\n previously committed.\n @note (@cyan): ZS2_Data_byteSize() is another name candidate."]
    #[link_name = "ZL_Input_contentSize__extern"]
    pub fn ZL_Input_contentSize(input: *const ZL_Input) -> usize;
}
extern "C" {
    #[doc = " These methods provide direct access to internal buffer.\n Warning : users must pay attention to buffer boundaries.\n @return pointer to the _beginning_ of buffer.\n @note for `ZL_Type_string`, returns a pointer to the buffer containing the\n concatenated strings."]
    #[link_name = "ZL_Input_ptr__extern"]
    pub fn ZL_Input_ptr(input: *const ZL_Input) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n @return a pointer to the array of string lengths.\n The size of this array is `== ZL_Data_numElts(data)`.\n @return `NULL` if incorrect data type, or `StringLens` not allocated yet."]
    #[link_name = "ZL_Input_stringLens__extern"]
    pub fn ZL_Input_stringLens(input: *const ZL_Input) -> *const u32;
}
extern "C" {
    #[doc = " @returns The value if present. ZL_IntMetadata::isPresent != 0\n when the @p key exists, in which case ZL_IntMetadata::mValue is set to the\n value."]
    #[link_name = "ZL_Input_getIntMetadata__extern"]
    pub fn ZL_Input_getIntMetadata(
        input: *const ZL_Input,
        key: ::std::os::raw::c_int,
    ) -> ZL_IntMetadata;
}
extern "C" {
    #[doc = " @brief Sets integer metadata with the key @p key and value @p value on the\n stream.\n\n It is only valid to call ZL_Input_setIntMetadata() with the same @p key\n once. Subsequent calls with the same @p key will return an error.\n\n @param key Metdata key\n @param value Metadata value\n\n @returns Success or an error. This function will fail due to repeated calls\n with the same @p key, or upon running out of space for the metadata.\n\n @note In this proposed design, Int Metadata are set one by one.\n Another possible design could follow the IntParams\n model, where all parameters must be set all-at-once, and be\n provided as a single vector of IntParams structures.\n\n @note The set value is an int, hence it's not suitable to store \"large\"\n values, like 64-bit ULL."]
    #[link_name = "ZL_Input_setIntMetadata__extern"]
    pub fn ZL_Input_setIntMetadata(
        input: *mut ZL_Input,
        key: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
#[doc = " The function signature for function graphs.\n\n @param graph The graph object containing the graph context\n @param inputs The inputs passed into the function graph to compress\n @param nbInputs The number of inputs in @p inputs"]
pub type ZL_FunctionGraphFn = ::std::option::Option<
    unsafe extern "C" fn(
        graph: *mut ZL_Graph,
        inputs: *mut *mut ZL_Edge,
        nbInputs: usize,
    ) -> ZL_Report,
>;
pub type ZL_FunctionGraphValidateFn = ::std::option::Option<
    unsafe extern "C" fn(
        compressor: *const ZL_Compressor,
        dgd: *const ZL_FunctionGraphDesc,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_FunctionGraphDesc {
    pub name: *const ::std::os::raw::c_char,
    pub graph_f: ZL_FunctionGraphFn,
    pub validate_f: ZL_FunctionGraphValidateFn,
    pub inputTypeMasks: *const ZL_Type,
    pub nbInputs: usize,
    pub lastInputIsVariable: ::std::os::raw::c_int,
    pub customGraphs: *const ZL_GraphID,
    pub nbCustomGraphs: usize,
    pub customNodes: *const ZL_NodeID,
    pub nbCustomNodes: usize,
    pub localParams: ZL_LocalParams,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Graph_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the compressor."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_FunctionGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_FunctionGraphDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_FunctionGraphDesc>(),
        152usize,
        "Size of ZL_FunctionGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_FunctionGraphDesc>(),
        8usize,
        "Alignment of ZL_FunctionGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_FunctionGraphDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_f) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_FunctionGraphDesc::graph_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).validate_f) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_FunctionGraphDesc::validate_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputTypeMasks) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_FunctionGraphDesc::inputTypeMasks"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbInputs) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_FunctionGraphDesc::nbInputs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastInputIsVariable) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_FunctionGraphDesc::lastInputIsVariable"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customGraphs) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_FunctionGraphDesc::customGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomGraphs) as usize - ptr as usize },
        56usize,
        "Offset of field: ZL_FunctionGraphDesc::nbCustomGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customNodes) as usize - ptr as usize },
        64usize,
        "Offset of field: ZL_FunctionGraphDesc::customNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomNodes) as usize - ptr as usize },
        72usize,
        "Offset of field: ZL_FunctionGraphDesc::nbCustomNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_FunctionGraphDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        128usize,
        "Offset of field: ZL_FunctionGraphDesc::opaque"
    );
}
extern "C" {
    #[doc = " Registers a function graph given the @p desc.\n\n @note This is a new variant of @ref ZL_Compressor_registerFunctionGraph that\n reports errors using OpenZL's ZL_Report error system.\n\n @param desc The description of the graph, must be non-null.\n\n @return The new graph ID, or an error."]
    pub fn ZL_Compressor_registerFunctionGraph2(
        compressor: *mut ZL_Compressor,
        dgd: *const ZL_FunctionGraphDesc,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    pub fn ZL_Compressor_registerFunctionGraph(
        compressor: *mut ZL_Compressor,
        dgd: *const ZL_FunctionGraphDesc,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Registration might fail if the Descriptor is incorrectly filled,\n Any further operation attempted with such a Graph will also fail.\n Such an outcome can be tested with ZL_GraphID_isValid().\n Note: this is mostly for debugging purposes,\n once a Descriptor is valid, registration can be assumed to be successful."]
    pub fn ZL_GraphID_isValid(graphid: ZL_GraphID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ZL_Graph_getCustomGraphs(gctx: *const ZL_Graph) -> ZL_GraphIDList;
}
extern "C" {
    pub fn ZL_Graph_getCustomNodes(gctx: *const ZL_Graph) -> ZL_NodeIDList;
}
extern "C" {
    pub fn ZL_Graph_getCParam(gctx: *const ZL_Graph, gparam: ZL_CParam) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ZL_Graph_getLocalIntParam(
        gctx: *const ZL_Graph,
        intParamId: ::std::os::raw::c_int,
    ) -> ZL_IntParam;
}
extern "C" {
    pub fn ZL_Graph_getLocalRefParam(
        gctx: *const ZL_Graph,
        refParamId: ::std::os::raw::c_int,
    ) -> ZL_RefParam;
}
extern "C" {
    #[doc = " Determines whether @nodeid is supported given the applied global parameters\n for the compression.\n Notably the ZL_CParam_formatVersion parameter can determine if a node is\n valid for the given encoding version."]
    pub fn ZL_Graph_isNodeSupported(gctx: *const ZL_Graph, nodeid: ZL_NodeID) -> bool;
}
extern "C" {
    pub fn ZL_Graph_getOpaquePtr(graph: *const ZL_Graph) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_Edge_getData(sctx: *const ZL_Edge) -> *const ZL_Input;
}
#[doc = " @defgroup Group_Compressor_GraphCustomization Graph Customization\n\n Graphs can be customized to override their name, local parameters, custom\n nodes and custom graphs. This is an advanced use case, and mainly an\n implementation detail of graphs. Most graphs which accept parameters provide\n helper functions to correctly parameterize the graph.\n\n @{"]
pub type ZL_RuntimeGraphParameters = ZL_GraphParameters_s;
extern "C" {
    pub fn ZL_Graph_getScratchSpace(
        gctx: *mut ZL_Graph,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A measurement of graph performance.\n Currently this is compressed size, but it is expected to be expanded to\n include speed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_GraphPerformance {
    #[doc = " The compressed size of the graph on the given input(s)"]
    pub compressedSize: usize,
}
#[test]
fn bindgen_test_layout_ZL_GraphPerformance() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphPerformance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphPerformance>(),
        8usize,
        "Size of ZL_GraphPerformance"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphPerformance>(),
        8usize,
        "Alignment of ZL_GraphPerformance"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressedSize) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphPerformance::compressedSize"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Result_ZL_GraphPerformance_inner {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_GraphPerformance,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_GraphPerformance_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_GraphPerformance_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_GraphPerformance_inner>(),
        16usize,
        "Size of ZL_Result_ZL_GraphPerformance_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_GraphPerformance_inner>(),
        8usize,
        "Alignment of ZL_Result_ZL_GraphPerformance_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphPerformance_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Result_ZL_GraphPerformance_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_ZL_GraphPerformance_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_ZL_GraphPerformance_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_GraphPerformance_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_GraphPerformance_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_GraphPerformance_u>(),
        16usize,
        "Size of ZL_Result_ZL_GraphPerformance_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_GraphPerformance_u>(),
        8usize,
        "Alignment of ZL_Result_ZL_GraphPerformance_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphPerformance_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphPerformance_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_GraphPerformance_u::_error"
    );
}
pub type ZL_Result_ZL_GraphPerformance = ZL_Result_ZL_GraphPerformance_u;
extern "C" {
    #[link_name = "ZL_Result_ZL_GraphPerformance_extract__extern"]
    pub fn ZL_Result_ZL_GraphPerformance_extract(
        result: ZL_Result_ZL_GraphPerformance,
        error: *mut ZL_Error,
    ) -> ZL_GraphPerformance;
}
pub type ZL_Result_ZL_GraphPerformance_fake_type_needs_semicolon = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Attempt compression using a graph and return the performance.\n\n This API allows the user to simulate the execution of a given @p graphID\n on an input to measure its performance. This API is wasteful in CPU and\n memory and should only be used when there is no better choice.\n\n @param input The input to try compress on\n @param graphID The GraphID to use to compress the @p input\n @param params The runtime parameters for the @p graphID, or `NULL` to not\n parameterize the graph.\n\n @returns If the compression failed it returns a non-fatal error. Otherwise,\n it returns the performance of the @p graphID on the @p input."]
    pub fn ZL_Graph_tryGraph(
        gctx: *const ZL_Graph,
        input: *const ZL_Input,
        graphID: ZL_GraphID,
        params: *const ZL_RuntimeGraphParameters,
    ) -> ZL_Result_ZL_GraphPerformance;
}
extern "C" {
    #[doc = " @brief Attempt compression using a graph and return the performance.\n\n The same as @ref ZL_Graph_tryGraph except it accepts multiple inputs."]
    pub fn ZL_Graph_tryMultiInputGraph(
        gctx: *const ZL_Graph,
        inputs: *mut *const ZL_Input,
        numInputs: usize,
        graphID: ZL_GraphID,
        params: *const ZL_RuntimeGraphParameters,
    ) -> ZL_Result_ZL_GraphPerformance;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ZL_EdgeList {
    pub field_1: ZL_EdgeList__bindgen_ty_1,
    pub field_2: ZL_EdgeList__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_EdgeList__bindgen_ty_1 {
    pub edges: *mut *mut ZL_Edge,
    pub streams: *mut *mut ZL_Edge,
}
#[test]
fn bindgen_test_layout_ZL_EdgeList__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_EdgeList__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_EdgeList__bindgen_ty_1>(),
        8usize,
        "Size of ZL_EdgeList__bindgen_ty_1"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_EdgeList__bindgen_ty_1>(),
        8usize,
        "Alignment of ZL_EdgeList__bindgen_ty_1"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edges) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_EdgeList__bindgen_ty_1::edges"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_EdgeList__bindgen_ty_1::streams"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_EdgeList__bindgen_ty_2 {
    pub nbEdges: usize,
    pub nbStreams: usize,
}
#[test]
fn bindgen_test_layout_ZL_EdgeList__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_EdgeList__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_EdgeList__bindgen_ty_2>(),
        8usize,
        "Size of ZL_EdgeList__bindgen_ty_2"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_EdgeList__bindgen_ty_2>(),
        8usize,
        "Alignment of ZL_EdgeList__bindgen_ty_2"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbEdges) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_EdgeList__bindgen_ty_2::nbEdges"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbStreams) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_EdgeList__bindgen_ty_2::nbStreams"
    );
}
#[test]
fn bindgen_test_layout_ZL_EdgeList() {
    assert_eq!(
        ::std::mem::size_of::<ZL_EdgeList>(),
        16usize,
        "Size of ZL_EdgeList"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_EdgeList>(),
        8usize,
        "Alignment of ZL_EdgeList"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ZL_Result_ZL_EdgeList_inner {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_EdgeList,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_EdgeList_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_EdgeList_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_EdgeList_inner>(),
        24usize,
        "Size of ZL_Result_ZL_EdgeList_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_EdgeList_inner>(),
        8usize,
        "Alignment of ZL_Result_ZL_EdgeList_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_EdgeList_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Result_ZL_EdgeList_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_ZL_EdgeList_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_ZL_EdgeList_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_EdgeList_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_EdgeList_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_EdgeList_u>(),
        24usize,
        "Size of ZL_Result_ZL_EdgeList_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_EdgeList_u>(),
        8usize,
        "Alignment of ZL_Result_ZL_EdgeList_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_EdgeList_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_EdgeList_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_EdgeList_u::_error"
    );
}
pub type ZL_Result_ZL_EdgeList = ZL_Result_ZL_EdgeList_u;
extern "C" {
    #[link_name = "ZL_Result_ZL_EdgeList_extract__extern"]
    pub fn ZL_Result_ZL_EdgeList_extract(
        result: ZL_Result_ZL_EdgeList,
        error: *mut ZL_Error,
    ) -> ZL_EdgeList;
}
pub type ZL_Result_ZL_EdgeList_fake_type_needs_semicolon = ::std::os::raw::c_int;
extern "C" {
    pub fn ZL_Edge_runNode(input: *mut ZL_Edge, nid: ZL_NodeID) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    pub fn ZL_Edge_runNode_withParams(
        input: *mut ZL_Edge,
        nid: ZL_NodeID,
        localParams: *const ZL_LocalParams,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    pub fn ZL_Edge_runMultiInputNode(
        inputs: *mut *mut ZL_Edge,
        nbInputs: usize,
        nid: ZL_NodeID,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    pub fn ZL_Edge_runMultiInputNode_withParams(
        inputs: *mut *mut ZL_Edge,
        nbInputs: usize,
        nid: ZL_NodeID,
        localParams: *const ZL_LocalParams,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    #[doc = " @brief Sets the int metadata for the edge to @p mValue\n\n @param mId The identifier for the stream metadata on the edge to set metadata\n on\n @param mValue The value to set stream metadata"]
    pub fn ZL_Edge_setIntMetadata(
        edge: *mut ZL_Edge,
        mId: ::std::os::raw::c_int,
        mValue: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    pub fn ZL_Edge_setDestination(edge: *mut ZL_Edge, gid: ZL_GraphID) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Sets the destination of the provided edges to the provided graph ID,\n overriding its behavior with the provided parameters.\n\n @param edges Array of edges to direct towards the successor graph.\n @param nbInputs The number of edges in the provided array.\n @param gid The ID of the successor graph.\n @param rGraphParams The parameters to use for the successor graph. NULL means\n don't override."]
    pub fn ZL_Edge_setParameterizedDestination(
        edges: *mut *mut ZL_Edge,
        nbInputs: usize,
        gid: ZL_GraphID,
        rGraphParams: *const ZL_RuntimeGraphParameters,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Helper function to parameterize the `ZL_NODE_CONVERT_SERIAL_TO_STRUCT` node\n with the struct size.\n\n Input: Serial\n Output: Struct"]
    pub fn ZL_Compressor_parameterizeConvertSerialToStructNode(
        compressor: *mut ZL_Compressor,
        structSize: ::std::os::raw::c_int,
    ) -> ZL_Result_ZL_NodeID;
}
extern "C" {
    #[doc = " Convert from serial to `bitWidth`-bit little-endian numeric data.\n\n @pre bitWidth must be 8, 16, 32, or 64.\n\n Input: Serial\n Output: Numeric"]
    pub fn ZL_Node_convertSerialToNumLE(bitWidth: usize) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Convert from serial to `bitWidth`-bit big-endian numeric data.\n\n @pre bitWidth must be 8, 16, 32, or 64.\n\n Input: Serial\n Output: Numeric"]
    pub fn ZL_Node_convertSerialToNumBE(bitWidth: usize) -> ZL_NodeID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SetStringLensInstructions {
    pub stringLens: *const u32,
    pub nbStrings: usize,
}
#[test]
fn bindgen_test_layout_ZL_SetStringLensInstructions() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SetStringLensInstructions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SetStringLensInstructions>(),
        16usize,
        "Size of ZL_SetStringLensInstructions"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SetStringLensInstructions>(),
        8usize,
        "Alignment of ZL_SetStringLensInstructions"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stringLens) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SetStringLensInstructions::stringLens"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbStrings) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SetStringLensInstructions::nbStrings"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SetStringLensState_s {
    _unused: [u8; 0],
}
pub type ZL_SetStringLensState = ZL_SetStringLensState_s;
pub type ZL_SetStringLensParserFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ZL_SetStringLensState,
        in_: *const ZL_Input,
    ) -> ZL_SetStringLensInstructions,
>;
extern "C" {
    pub fn ZL_SetStringLensState_getOpaquePtr(
        state: *const ZL_SetStringLensState,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_SetStringLensState_malloc(
        state: *mut ZL_SetStringLensState,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_Compressor_registerConvertSerialToStringNode(
        cgraph: *mut ZL_Compressor,
        f: ZL_SetStringLensParserFn,
        opaque: *const ::std::os::raw::c_void,
    ) -> ZL_NodeID;
}
extern "C" {
    pub fn ZL_Edge_runConvertSerialToStringNode(
        sctx: *mut ZL_Edge,
        stringLens: *const u32,
        nbString: usize,
    ) -> ZL_Result_ZL_EdgeList;
}
pub const ZL_trlip_tokenSize: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "ZL_Node_interpretAsLE__extern"]
    pub fn ZL_Node_interpretAsLE(bitWidth: usize) -> ZL_NodeID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DispatchInstructions {
    pub segmentSizes: *const usize,
    pub tags: *const ::std::os::raw::c_uint,
    pub nbSegments: usize,
    pub nbTags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ZL_DispatchInstructions() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_DispatchInstructions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_DispatchInstructions>(),
        32usize,
        "Size of ZL_DispatchInstructions"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_DispatchInstructions>(),
        8usize,
        "Alignment of ZL_DispatchInstructions"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentSizes) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_DispatchInstructions::segmentSizes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_DispatchInstructions::tags"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbSegments) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_DispatchInstructions::nbSegments"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbTags) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_DispatchInstructions::nbTags"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DispatchState_s {
    _unused: [u8; 0],
}
pub type ZL_DispatchState = ZL_DispatchState_s;
extern "C" {
    pub fn ZL_DispatchState_malloc(
        state: *mut ZL_DispatchState,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Provides an opaque pointer that can be useful to provide state to the parser.\n For example, it can be used by language bindings to allow parsers written in\n languages other than C.\n\n @returns The opaque pointer provided to @fn\n ZL_Compressor_registerDispatchNode(). WARNING: ZStrong does not manage the\n lifetime of this pointer, it must outlive the ZL_Compressor."]
    pub fn ZL_DispatchState_getOpaquePtr(
        state: *const ZL_DispatchState,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns An error from the parser function and places the @p message into\n Zstrong's error context."]
    pub fn ZL_DispatchState_returnError(
        state: *mut ZL_DispatchState,
        message: *const ::std::os::raw::c_char,
    ) -> ZL_DispatchInstructions;
}
pub type ZL_DispatchParserFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut ZL_DispatchState,
        in_: *const ZL_Input,
    ) -> ZL_DispatchInstructions,
>;
extern "C" {
    pub fn ZL_Compressor_registerDispatchNode(
        cgraph: *mut ZL_Compressor,
        f: ZL_DispatchParserFn,
        opaque: *const ::std::os::raw::c_void,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Run the DispatchN node in the context of a dynamic graph,\n following runtime-defined  @p instructions.\n\n @returns The list of Streams produced by the Transform,\n or an error if the operation fails (invalid instruction or input for example)"]
    pub fn ZL_Edge_runDispatchNode(
        sctx: *mut ZL_Edge,
        instructions: *const ZL_DispatchInstructions,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    #[doc = " Convenience function to get the maximum number of dispatches supported by the\n current encoder version."]
    pub fn ZL_DispatchString_maxDispatches() -> usize;
}
extern "C" {
    #[doc = " @param nbOutputs - the number of output streams to be generated. Passed as a\n local param to the transform.\n @param dispatchIndices - the array of indices to be used for dispatching.\n Will be passed as a local param to the transform. The lifetime of the array\n is to be managed by the caller and should outlive the transform execution."]
    pub fn ZL_Compressor_registerDispatchStringNode(
        cgraph: *mut ZL_Compressor,
        nbOutputsParam: ::std::os::raw::c_int,
        dispatchIndicesParam: *const u16,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Run the ZL_NODE_DISPATCH_STRING Node in the context of a Dynamic Graph,\n applying runtime defined parameters."]
    pub fn ZL_Edge_runDispatchStringNode(
        sctx: *mut ZL_Edge,
        nbOutputs: ::std::os::raw::c_int,
        indices: *const u16,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    #[doc = " Creates the divide by node with its divisor set to @p divisor.\n\n @returns Returns the modified divide by node with its divisor set to @p\n divisor."]
    pub fn ZL_Compressor_registerDivideByNode(
        cgraph: *mut ZL_Compressor,
        divisor: u64,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " DEPRECATED: Use ZL_GRAPH_FIELD_LZ instead.\n @returns ZL_GRAPH_FIELD_LZ"]
    pub fn ZL_Compressor_registerFieldLZGraph(cgraph: *mut ZL_Compressor) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @returns ZL_GRAPH_FIELD_LZ with overridden compression level"]
    pub fn ZL_Compressor_registerFieldLZGraph_withLevel(
        cgraph: *mut ZL_Compressor,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Creates a Field LZ graph with a custom literals compressor.\n\n Field LZ compresses a fixed size field stream using LZ compression\n that only matches entire fields.\n\n Input: A fixed size stream of width 1, 2, 4, or 8.\n\n @param literalsGraph a graph which takes a fixed size field of the\n same width as the input. All fields that we can't find matches for\n are passed to the literals stream."]
    pub fn ZL_Compressor_registerFieldLZGraph_withLiteralsGraph(
        cgraph: *mut ZL_Compressor,
        literalsGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Creates a graph for ZL_NODE_MERGE_SORTED that first detects whether\n the input has <= 64 sorted runs. If it does it selects the node.\n Otherwise it selects the backupGraph."]
    pub fn ZL_Compressor_registerMergeSortedGraph(
        cgraph: *mut ZL_Compressor,
        bitsetGraph: ZL_GraphID,
        mergedGraph: ZL_GraphID,
        backupGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Returns a parameterized version of the try parse int graph with the required\n successors of the graph.\n\n @param numSuccessor The successor to send strings that successfully parse as\n integers\n @param exceptionSucesssor The successor to send strings that fail to parse as\n integers\n @return The graphID for the parameterized Try Parse Int graph"]
    pub fn ZL_Compressor_parameterizeTryParseIntGraph(
        compressor: *mut ZL_Compressor,
        numSuccessor: ZL_GraphID,
        exceptionSuccessor: ZL_GraphID,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    #[doc = " Builds a Simple Data Description Language graph with the provided\n (pre-compiled) @p description and @p successor graph.\n\n See the SDDL page in the documentation for a complete description of this\n component.\n\n ### Graph Topology\n\n ``` mermaid\n flowchart TD\n     subgraph SDDL Graph\n         Desc([Description]);\n         Input([Input]);\n         Conv@{ shape: procs, label: \"Type Conversions\"};\n         Engine[SDDL Engine];\n         Inst([Instructions]);\n         Disp[/Dispatch Transform\\];\n         Succ[Successor Graph];\n\n         Desc --> Engine;\n         Input --> Engine;\n         Engine --> Inst;\n         Inst -->|Dispatch Instructions| Disp;\n         Input --> Disp;\n         Inst -->|Type Information| Conv;\n         Disp ==>|Many Streams| Conv;\n         Conv ==>|Many Streams| Succ;\n     end\n\n     OuterInput[ZL_Input] --> Input;\n     OuterParam[ZL_LocalCopyParam] --> Desc;\n ```\n\n This graph takes a single serial input and applies the @p description to it,\n using that description to decompose the input into fields which are mapped\n to one or more output streams. These streams, as well as two control streams\n are all sent to a single invocation of the @p successor graph. @p successor\n must therefore be a multi-input graph able to accept any number of numeric\n and serial streams (at least).\n\n (The control streams are: a numeric stream containing the stream indices\n into which each field has been placed and a numeric stream containing the\n size of each field. See also the documentation for `dispatchN_byTag` and\n particularly, @ref ZL_Edge_runDispatchNode, which is the underlying\n component that this graph uses to actually decompose the input, for more\n information about the dispatch operation. These streams respectively are the\n first and second stream passed into the successor graph, and the streams\n into which the input has been dispatched follow, in order.)\n\n The streams on which the @p successor is invoked are also tagged with int\n metadata, with key 0 set to their index. (For the moment. Future work may\n allow for more robust/stable tagging.) This makes this graph compatible with\n the generic clustering graph (see @ref ZL_Clustering_registerGraph), and the\n `sddl` profile in the demo CLI, for example, is set up that way, with the\n SDDL graph succeeded by the generic clusterer.\n\n ### Data Description\n\n This graph requires a @p description of the input format that it is intended\n to parse and dispatch. SDDL has both a human-writeable description language\n and a binary, compiled representation of that language. This component only\n accepts descriptions in the binary format.\n\n Use @ref openzl::sddl::Compiler::compile to do that translation.\n\n Note that the OpenZL demo CLI can also compile SDDL descriptions, as part of\n using the `sddl` profile."]
    pub fn ZL_Compressor_buildSDDLGraph(
        compressor: *mut ZL_Compressor,
        description: *const ::std::os::raw::c_void,
        descriptionSize: usize,
        successor: ZL_GraphID,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    pub fn ZL_Compressor_registerSplitNode_withParams(
        cgraph: *mut ZL_Compressor,
        type_: ZL_Type,
        segmentSizes: *const usize,
        nbSegments: usize,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Run the SplitN node within the context of a dynamic graph,\n applying runtime-defined @p segmentSizes parameters.\n\n @returns the list of Streams created by the Transform\n or an error if the splitting process fails (invalid segment sizes or input\n type for example)"]
    pub fn ZL_Edge_runSplitNode(
        input: *mut ZL_Edge,
        segmentSizes: *const usize,
        nbSegments: usize,
    ) -> ZL_Result_ZL_EdgeList;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SplitInstructions {
    pub segmentSizes: *const usize,
    pub nbSegments: usize,
}
#[test]
fn bindgen_test_layout_ZL_SplitInstructions() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SplitInstructions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SplitInstructions>(),
        16usize,
        "Size of ZL_SplitInstructions"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SplitInstructions>(),
        8usize,
        "Alignment of ZL_SplitInstructions"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentSizes) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SplitInstructions::segmentSizes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbSegments) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SplitInstructions::nbSegments"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SplitState_s {
    _unused: [u8; 0],
}
pub type ZL_SplitState = ZL_SplitState_s;
extern "C" {
    pub fn ZL_SplitState_malloc(
        state: *mut ZL_SplitState,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Provides an opaque pointer that can be useful to provide state to the parser.\n For example, it can be used by language bindings to allow parsers written in\n languages other than C.\n\n @returns The opaque pointer provided to @fn\n ZL_Compressor_registerSplitNode_withParser(). WARNING: ZStrong does not\n manage the lifetime of this pointer, it must outlive the ZL_Compressor."]
    pub fn ZL_SplitState_getOpaquePtr(state: *mut ZL_SplitState) -> *const ::std::os::raw::c_void;
}
pub type ZL_SplitParserFn = ::std::option::Option<
    unsafe extern "C" fn(state: *mut ZL_SplitState, in_: *const ZL_Input) -> ZL_SplitInstructions,
>;
extern "C" {
    pub fn ZL_Compressor_registerSplitNode_withParser(
        cgraph: *mut ZL_Compressor,
        type_: ZL_Type,
        f: ZL_SplitParserFn,
        opaque: *const ::std::os::raw::c_void,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Split-by-param\n This operation splits a serialized input\n into segments, defined by array @segmentSizes[].\n The nb of segments and their size is static,\n except for the last segment size, which can receive a size value `0`,\n meaning \"whatever is left in the stream\".\n Each segment is then into its own output,\n and then sent to the next processing stage defined by @successors[]."]
    pub fn ZL_Compressor_registerSplitGraph(
        cgraph: *mut ZL_Compressor,
        type_: ZL_Type,
        segmentSizes: *const usize,
        successors: *const ZL_GraphID,
        nbSegments: usize,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Split-by-struct\n This operation splits a serialized input\n defined as an array of structures of fixed size,\n by grouping same fields into their own stream.\n All fields are considered concatenated back-to-back (no alignment).\n For this transform to work, input must be an exact multiple of struct_size,\n with struct_size = sum(field_sizes).\n Each output stream is then assigned a successor Graph."]
    pub fn ZL_Compressor_registerSplitByStructGraph(
        cgraph: *mut ZL_Compressor,
        fieldSizes: *const usize,
        successors: *const ZL_GraphID,
        nbFields: usize,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Builds a tokenize node for the given parameters.\n\n Input: @p inputType\n Output 0: @p inputType - alphabet of unique values\n Output 1: numeric - indices into the alphabet for each value\n\n @param inputType The type of the input data. It can be either struct,\n numeric, or string.\n @param sort Whether or not to sort the alphabet. Struct types cannot be\n sorted. Numeric types are sorted in ascending order. String types are sorted\n in lexographical order.\n\n @returns The tokenize node, or an error."]
    pub fn ZL_Compressor_parameterizeTokenizeNode(
        compressor: *mut ZL_Compressor,
        inputType: ZL_Type,
        sort: bool,
    ) -> ZL_Result_ZL_NodeID;
}
extern "C" {
    #[doc = " Builds a tokenize graph for the given parameters & successors.\n\n @note If sorting the alphabet is not beneficial avoid it, as the sort will\n slow down compression.\n\n @param inputType The type of the input data. It can be either struct,\n numeric, or string.\n @param sort Whether or not to sort the alphabet. Struct types cannot be\n sorted. Numeric types are sorted in ascending order. String types are sorted\n in lexographical order.\n @param alphabetGraph The graph to pass the alphabet output to. It must accept\n an input of type @p inputType.\n @param indicesGraph The graph to pass the indices to. It must accept a\n numeric input.\n\n @returns The tokenize graph, or an error."]
    pub fn ZL_Compressor_buildTokenizeGraph(
        compressor: *mut ZL_Compressor,
        inputType: ZL_Type,
        sort: bool,
        alphabetGraph: ZL_GraphID,
        indicesGraph: ZL_GraphID,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    #[doc = " @see ZL_Compressor_buildTokenizeGraph\n @returns The tokenize graph, or ZL_GRAPH_ILLEGAL on error."]
    pub fn ZL_Compressor_registerTokenizeGraph(
        compressor: *mut ZL_Compressor,
        inputType: ZL_Type,
        sort: bool,
        alphabetGraph: ZL_GraphID,
        indicesGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CustomTokenizeState_s {
    _unused: [u8; 0],
}
pub type ZL_CustomTokenizeState = ZL_CustomTokenizeState_s;
extern "C" {
    #[doc = " @returns The opaque pointer passed into @fn ZS2_createGraph_customTokenize()."]
    pub fn ZL_CustomTokenizeState_getOpaquePtr(
        ctx: *const ZL_CustomTokenizeState,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creates the alphabet stream to store the tokenized alphabet. The width of\n each element in the alphabet must be the same width as the input stream.\n\n @param alphabetSize The exact size of the alphabet.\n\n @returns A pointer to write the alphabet into or NULL on error."]
    pub fn ZL_CustomTokenizeState_createAlphabetOutput(
        ctx: *mut ZL_CustomTokenizeState,
        alphabetSize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creates the index stream with the given width. The index stream must contain\n exactly the same number of elements as the input.\n\n @param indexWidth The width of the index integer, either 1, 2, 4, or 8.\n\n @returns A pointer to write the indices into or NULL on error."]
    pub fn ZL_CustomTokenizeState_createIndexOutput(
        ctx: *mut ZL_CustomTokenizeState,
        indexWidth: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A custom tokenization function to tokenize the input. The output of this\n function is not checked in production builds, and it is UB to tokenize\n incorrectly."]
pub type ZL_CustomTokenizeFn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ZL_CustomTokenizeState, input: *const ZL_Input) -> ZL_Report,
>;
extern "C" {
    #[doc = " Tokenize with a custom tokenization function. This is useful if you want to\n define a custom order for your alphabet that is neither insertion nor sorted\n order.\n\n WARNING: Zstrong does not manage the lifetime of the @p opaque pointer. It\n must outlive the @p cgraph or be NULL."]
    pub fn ZL_Compressor_registerCustomTokenizeGraph(
        cgraph: *mut ZL_Compressor,
        streamType: ZL_Type,
        customTokenizeFn: ZL_CustomTokenizeFn,
        opaque: *const ::std::os::raw::c_void,
        alphabetGraph: ZL_GraphID,
        indicesGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Helper function to create a graph for ZL_NODE_TRANSPOSE_SPLIT.\n\n For frame format versions >= 11 ZL_NODE_TRANSPOSE_SPLIT is used and\n any eltWidth is supported.\n For frame format versions < 11 only eltWidth = 1, 2, 4, 8 is supported.\n Using other sizes will fail compression.\n\n Input: A fixed-size-field stream\n Output: eltWidth serialized streams of size nbElts\n Result: Convert a stream of N fields of size S into S streams of N fields by\n transposing the input stream.\n Example : 1 2 3 4 5 6 7 8 as 2 fields of size 4\n           => transposed into 4 streams as 2 fields of size 1\n           => (1, 5), (2, 6), (3, 7), (4, 8)"]
    pub fn ZL_Compressor_registerTransposeSplitGraph(
        cgraph: *mut ZL_Compressor,
        successor: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @returns a NodeID that implements transpose split for the given @p eltWidth\n that will work with any Zstrong format version. If no node exists, then\n returns ZL_NODE_ILLEGAL. This can happen for format version <= 10 when\n @p eltWidth != 2,4,8."]
    pub fn ZL_Graph_getTransposeSplitNode(gctx: *const ZL_Graph, eltWidth: usize) -> ZL_NodeID;
}
extern "C" {
    pub fn ZL_Edge_runTransposeSplit(
        edge: *mut ZL_Edge,
        graph: *const ZL_Graph,
    ) -> ZL_Result_ZL_EdgeList;
}
extern "C" {
    #[doc = " @return zstd graph with a compression level overridden"]
    pub fn ZL_Compressor_registerZstdGraph_withLevel(
        cgraph: *mut ZL_Compressor,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Create a new @ref ZL_Compressor.\n\n The @ref ZL_Compressor must be freed with @ref ZL_Compressor_free.\n\n @returns The @ref ZL_Compressor pointer or `NULL` on error."]
    pub fn ZL_Compressor_create() -> *mut ZL_Compressor;
}
extern "C" {
    #[doc = " @brief Frees a @ref ZL_Compressor.\n\n If @p compressor is `NULL` this function does nothing.\n\n @param compressor The @ref ZL_Compressor to free or `NULL`."]
    pub fn ZL_Compressor_free(compressor: *mut ZL_Compressor);
}
extern "C" {
    #[doc = " @returns A verbose error string containing context about the error that\n occurred. This is useful for debugging, and for submitting bug reports to\n OpenZL developers.\n @note This string is stored within the @p compressor and is only valid for\n the lifetime of the @p compressor."]
    pub fn ZL_Compressor_getErrorContextString(
        compressor: *const ZL_Compressor,
        report: ZL_Report,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " See @ref ZL_Compressor_getErrorContextString()\n\n The same as ZL_Compressor_getErrorContextString() except works on a @ref\n ZL_Error."]
    pub fn ZL_Compressor_getErrorContextString_fromError(
        compressor: *const ZL_Compressor,
        error: ZL_Error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns The array of warnings that were encountered during the creation\n of the compressor.\n @note The array's and the errors' lifetimes are valid until the next non-\n const call on the compressor."]
    pub fn ZL_Compressor_getWarnings(compressor: *const ZL_Compressor) -> ZL_Error_Array;
}
extern "C" {
    #[doc = " @brief Set global parameters via @p compressor. In this construction, global\n parameters are attached to a Compressor object. Global Parameters set at\n Compressor level can be overridden later at CCtx level.\n\n @returns Success or an error which can be checked with ZL_isError().\n @param gcparam The global parameter to set.\n @param value The value to set for the global parameter."]
    pub fn ZL_Compressor_setParameter(
        compresor: *mut ZL_Compressor,
        gcparam: ZL_CParam,
        value: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Read a parameter's configured value in the Compressor and returns it.\n\n @returns Returns the value of the parameter if it is set, or 0 if unset.\n @param gcparam The global parameter to read."]
    pub fn ZL_Compressor_getParameter(
        compressor: *const ZL_Compressor,
        gcparam: ZL_CParam,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @defgroup Group_Compressor_StaticGraphCreation Static Graph Creation\n\n There are two types of graphs in OpenZL: static graphs and dynamic graphs.\n Static graphs take a single input, pass that input to a codec, and the\n outputs of that codec are sent to the successor graphs. Dynamic graphs are\n graphs that inspect the input at runtime to make different decisions. These\n are either function graphs or selectors.\n\n This API allows the construction of static graphs. The head node and the\n successor graphs must be specified. Additionally, a name can be provided for\n the graph, which can aid in debugging. Finally, the graph can be\n parameterized, which sends the local parameters to the head node.\n\n The main function is @ref ZL_Compressor_buildStaticGraph. The other functions\n are older variants that will eventually be removed.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_StaticGraphParameters {
    #[doc = " Optionally a name for the graph for debugging.\n If NULL, then the static graph will not have a name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Optionally local parameters to pass to the head node.\n If NULL, then the head node's local parameters will not be overridden."]
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_StaticGraphParameters() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_StaticGraphParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_StaticGraphParameters>(),
        16usize,
        "Size of ZL_StaticGraphParameters"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_StaticGraphParameters>(),
        8usize,
        "Alignment of ZL_StaticGraphParameters"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_StaticGraphParameters::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_StaticGraphParameters::localParams"
    );
}
extern "C" {
    #[doc = " Build a new graph out of pre-existing components. The new graph passes its\n data to @p headNode, and then each output of @p headNode is set to the\n corresponding @p successorGraph.\n\n @param headNode Pass the input data to this node\n @param successorGraphs Pass the outputs of @p headNode to these graphs\n @param numSuccessorGraphs Number of successor graphs\n @param params Optionally extra parameters for the static graph, or NULL.\n\n @returns Thew new graph ID, or an error."]
    pub fn ZL_Compressor_buildStaticGraph(
        compressor: *mut ZL_Compressor,
        headNode: ZL_NodeID,
        successorGraphs: *const ZL_GraphID,
        numSuccessorGraphs: usize,
        params: *const ZL_StaticGraphParameters,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Create a graph from a single input & output node.\n\n Simplified variant of @ref ZL_Compressor_registerStaticGraph_fromNode that\n only works for nodes that have one input and one output. Creates a new graph\n headed by\n @p headNode, whose output gets sent to @p dstGraph.\n\n @returns The newly created graph or `ZL_GRAPH_ILLEGAL` on error.\n The user may check for errors using ZL_GraphID_isValid().\n\n @param headNode The node executed first in the newly created graph.\n @param dstGraph The graph that will receive the output of @p headNode."]
    pub fn ZL_Compressor_registerStaticGraph_fromNode1o(
        compressor: *mut ZL_Compressor,
        headNode: ZL_NodeID,
        dstGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Creates a graph consisting of a series of nodes executed in succession\n in the order provided and then sent to @p dstGraph.\n\n @returns The newly created graph or `ZL_GRAPH_ILLEGAL` on error.\n The user may check for errors using ZL_GraphID_isValid().\n\n @param nodes The nodes to execute in the newly created graph.\n @param nbNodes The number of nodes in @p nodes.\n @param dstGraph The graph that will receive the output of the last node in @p\n nodes."]
    pub fn ZL_Compressor_registerStaticGraph_fromPipelineNodes1o(
        compressor: *mut ZL_Compressor,
        nodes: *const ZL_NodeID,
        nbNodes: usize,
        dstGraph: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Create a graph from a head node.\n\n Creates a new graph headed by @p headNode, which produces\n @p nbDstGraphs outcomes. Each outcome of @p headNode gets sent\n to the corresponding graph in @p dstGraphs.\n\n @param headNode The head node in the newly created graph.\n @param dstGraphs Array of graphs of size @p nbDstGraphs.\n @param nbDstGraphs Must be equal to the number of outputs of @p headNode.\n\n @returns The newly created graph or `ZL_GRAPH_ILLEGAL` on error.\n The user may check for errors using ZL_GraphID_isValid().\n\n @note Successor dstGraphs can only be employed in single-input mode.\n Multi-input Graphs can only be invoked from a function graph."]
    pub fn ZL_Compressor_registerStaticGraph_fromNode(
        compressor: *mut ZL_Compressor,
        headNode: ZL_NodeID,
        dstGraphs: *const ZL_GraphID,
        nbDstGraphs: usize,
    ) -> ZL_GraphID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_StaticGraphDesc {
    pub name: *const ::std::os::raw::c_char,
    pub headNodeid: ZL_NodeID,
    pub successor_gids: *const ZL_GraphID,
    pub nbGids: usize,
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_StaticGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_StaticGraphDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_StaticGraphDesc>(),
        40usize,
        "Size of ZL_StaticGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_StaticGraphDesc>(),
        8usize,
        "Alignment of ZL_StaticGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_StaticGraphDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headNodeid) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_StaticGraphDesc::headNodeid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).successor_gids) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_StaticGraphDesc::successor_gids"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbGids) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_StaticGraphDesc::nbGids"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_StaticGraphDesc::localParams"
    );
}
extern "C" {
    #[doc = " This is the more complete declaration variant, offering more control and\n capabilities.\n In order to be valid, a Static Graph Description must :\n - provide exactly as many successors as nb of outcomes defined by head Node\n - only employ single-input Graphs as successors\n - match each outcome type with a successor using a compatible input type\n - optionally, can specify @localParams for a Static Graph. In this case,\n   these parameters are forwarded to the Head Node, replacing any previous\n   local parameter that may have been already set on the Head Node.\n\n If a declaration is invalid, it results in an invalid GraphID, which can be\n tested using ZL_GraphID_isValid() on the return value.\n Note: ZL_GraphID_isValid() is currently defined in zs2_graph_api.h."]
    pub fn ZL_Compressor_registerStaticGraph(
        compressor: *mut ZL_Compressor,
        sgDesc: *const ZL_StaticGraphDesc,
    ) -> ZL_GraphID;
}
#[doc = " @defgroup Group_Compressor_NodeCustomization Node Customization\n\n Nodes can be customized to override their name and local parameters.\n This is an advanced use case, and mainly an implementation detail of nodes.\n Most nodes that accept parameters provide helper functions to correctly\n parameterize the node.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_NodeParameters {
    #[doc = " Optionally a new name, if NULL it is derived from the node's name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Optionally the new local params, if NULL then the parameters are not\n updated."]
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_NodeParameters() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_NodeParameters> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_NodeParameters>(),
        16usize,
        "Size of ZL_NodeParameters"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_NodeParameters>(),
        8usize,
        "Alignment of ZL_NodeParameters"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_NodeParameters::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_NodeParameters::localParams"
    );
}
extern "C" {
    #[doc = " Parameterize an existing node by overriding its name and/or local parameters.\n\n @param node The node to parameterize.\n @param params The new parameters, which must be non-null.\n\n @returns The new node ID on success, or an error."]
    pub fn ZL_Compressor_parameterizeNode(
        compressor: *mut ZL_Compressor,
        node: ZL_NodeID,
        params: *const ZL_NodeParameters,
    ) -> ZL_Result_ZL_NodeID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_ParameterizedNodeDesc {
    #[doc = " Optionally a new name, if NULL it is derived from the node's name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Node to parameterize"]
    pub node: ZL_NodeID,
    #[doc = " Optionally the new local params, if NULL then the parameters are not\n updated."]
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_ParameterizedNodeDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_ParameterizedNodeDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_ParameterizedNodeDesc>(),
        24usize,
        "Size of ZL_ParameterizedNodeDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_ParameterizedNodeDesc>(),
        8usize,
        "Alignment of ZL_ParameterizedNodeDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_ParameterizedNodeDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_ParameterizedNodeDesc::node"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_ParameterizedNodeDesc::localParams"
    );
}
extern "C" {
    #[doc = " @brief Clone an existing @ref ZL_NodeID from an existing node, but\n optionally with a new name & new parameters.\n\n @param desc The parameterization options.\n\n @returns The new node id of the cloned node."]
    pub fn ZL_Compressor_registerParameterizedNode(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_ParameterizedNodeDesc,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " @brief Simplified variant of @ref ZL_Compressor_registerParameterizedNode().\n Clone an existing @ref ZL_NodeID from an already registered\n @p nodeid but employs new parameters, set via @p localParams.\n\n @returns The new node id of the cloned node.\n\n @param nodeid The node to clone.\n @param localParams The local parameters to use for the node."]
    pub fn ZL_Compressor_cloneNode(
        compressor: *mut ZL_Compressor,
        nodeid: ZL_NodeID,
        localParams: *const ZL_LocalParams,
    ) -> ZL_NodeID;
}
#[doc = " @defgroup Group_Compressor_GraphCustomization Graph Customization\n\n Graphs can be customized to override their name, local parameters, custom\n nodes and custom graphs. This is an advanced use case, and mainly an\n implementation detail of graphs. Most graphs which accept parameters provide\n helper functions to correctly parameterize the graph.\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_GraphParameters_s {
    #[doc = " Optional, for debug traces, otherwise it is derived from graph's name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Empty means don't override"]
    pub customGraphs: *const ZL_GraphID,
    pub nbCustomGraphs: usize,
    #[doc = " Empty means don't override"]
    pub customNodes: *const ZL_NodeID,
    pub nbCustomNodes: usize,
    #[doc = " NULL means don't override"]
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_GraphParameters_s() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphParameters_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphParameters_s>(),
        48usize,
        "Size of ZL_GraphParameters_s"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphParameters_s>(),
        8usize,
        "Alignment of ZL_GraphParameters_s"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphParameters_s::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customGraphs) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_GraphParameters_s::customGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomGraphs) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_GraphParameters_s::nbCustomGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customNodes) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_GraphParameters_s::customNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomNodes) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_GraphParameters_s::nbCustomNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_GraphParameters_s::localParams"
    );
}
#[doc = " @defgroup Group_Compressor_GraphCustomization Graph Customization\n\n Graphs can be customized to override their name, local parameters, custom\n nodes and custom graphs. This is an advanced use case, and mainly an\n implementation detail of graphs. Most graphs which accept parameters provide\n helper functions to correctly parameterize the graph.\n\n @{"]
pub type ZL_GraphParameters = ZL_GraphParameters_s;
extern "C" {
    #[doc = " Parameterizes an existing graph by overriding its name, customGraphs,\n customNodes, and/or localParams.\n\n @param graph The graph to parameterize.\n @param params The new parameters, which must be non-null.\n\n @returns The new graph ID on success, or an error."]
    pub fn ZL_Compressor_parameterizeGraph(
        compressor: *mut ZL_Compressor,
        graph: ZL_GraphID,
        params: *const ZL_GraphParameters,
    ) -> ZL_Result_ZL_GraphID;
}
#[doc = " This creates a new Graphs, based on an existing Graph,\n but modifying all or parts of its exposed parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_ParameterizedGraphDesc {
    #[doc = " Optionally a new name, otherwise it is derived from `graph`'s name."]
    pub name: *const ::std::os::raw::c_char,
    pub graph: ZL_GraphID,
    #[doc = " Empty means don't override"]
    pub customGraphs: *const ZL_GraphID,
    pub nbCustomGraphs: usize,
    #[doc = " Empty means don't override"]
    pub customNodes: *const ZL_NodeID,
    pub nbCustomNodes: usize,
    #[doc = " NULL means don't override"]
    pub localParams: *const ZL_LocalParams,
}
#[test]
fn bindgen_test_layout_ZL_ParameterizedGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_ParameterizedGraphDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_ParameterizedGraphDesc>(),
        56usize,
        "Size of ZL_ParameterizedGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_ParameterizedGraphDesc>(),
        8usize,
        "Alignment of ZL_ParameterizedGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_ParameterizedGraphDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_ParameterizedGraphDesc::graph"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customGraphs) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_ParameterizedGraphDesc::customGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomGraphs) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_ParameterizedGraphDesc::nbCustomGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customNodes) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_ParameterizedGraphDesc::customNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomNodes) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_ParameterizedGraphDesc::nbCustomNodes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_ParameterizedGraphDesc::localParams"
    );
}
extern "C" {
    #[doc = " @brief Create a new GraphID by the one from @p gid,\n just replacing the @p localParams by the provided ones. Used to create\n custom variants of Standard Graphs for example.\n\n @note the original @gid still exists and remains accessible.\n @note @localParams==NULL means \"do not change the parameters\",\n       in which case, this function simply returns @gid.\n\n @return The GraphID of the newly created graph, or ZL_GRAPH_ILLEGAL on\n error.\n\n @param gid The GraphID to clone.\n @param localParams The local parameters to use inside the graph."]
    pub fn ZL_Compressor_registerParameterizedGraph(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_ParameterizedGraphDesc,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Lookup a node by name.\n\n Looks up a node with the given name and returns it. Anchor nodes (nodes whose\n name starts with '!') can be looked up by name, excluding the leading '!'.\n Standard nodes can also be looked up by name. Non-anchor nodes are assigned a\n unique name by suffixing them with `#${unique}`. They can be looked up if you\n know the unique name.\n\n @returns The node if it exists, or ZL_NODE_ILLEGAL."]
    pub fn ZL_Compressor_getNode(
        compressor: *const ZL_Compressor,
        name: *const ::std::os::raw::c_char,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " @brief Lookup a graph by name.\n\n Looks up a graph with the given name and returns it. Anchor graphs (graphs\n whose name starts with '!') can be looked up by name, excluding the leading\n '!'. Standard graphs can also be looked up by name. Non-anchor graphs are\n assigned a unique name by suffixing them with `#${unique}`. They can be\n looked up if you know the unique name.\n\n @returns The graph if it exists, or ZL_GRAPH_ILLEGAL."]
    pub fn ZL_Compressor_getGraph(
        compressor: *const ZL_Compressor,
        graph: *const ::std::os::raw::c_char,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @brief Selects a graph as the default entry point for the compressor.\n\n By default, a compressor's entry point is its most recently registered graph.\n This function allows explicit selection of a different graph as the default\n entry point for subsequent compression operations.\n\n @param compressor The compressor instance to configure. Must not be NULL.\n @param graph The graph ID to set as the default entry point. Must be a valid\n              graph ID that has been registered with this compressor.\n @returns ZL_Report indicating success or failure. Use ZL_isError() to check\n          for errors.\n\n @note The compressor can still be used as a collection of multiple entry\n points. Alternative entry points can be selected at runtime using\n       ZL_CCtx_selectStartingGraphID().\n @note This operation automatically validates the compressor by calling\n       ZL_Compressor_validate() internally.\n\n See ZL_CCtx_selectStartingGraphID() for runtime entry point selection"]
    pub fn ZL_Compressor_selectStartingGraphID(
        compressor: *mut ZL_Compressor,
        graph: ZL_GraphID,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Validates a graph maintains basic invariants to reduce the chance of\n errors being triggered when compressing.\n\n @note this operation is also integrated as part of\n ZL_Compressor_selectStartingGraphID(). This function is kept for backward\n compatibility.\n\n @returns Success if graph is valid, error otherwise.\n @param starting_graph The starting graph to validate."]
    pub fn ZL_Compressor_validate(
        compressor: *mut ZL_Compressor,
        starting_graph: ZL_GraphID,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Pass @p compressor as a `ZL_Compressor*` object to the compression\n state. Compression will start with the default Starting GraphID of @p\n compressor, using its default parameters provided at registration time.\n @note Only one compressor can be referenced at a time.\n       Referencing a new compressor deletes previous reference.\n @note If a custom GraphID and parameters were previously set,\n       invoking this method will reset them to default.\n @pre @p compressor must remain valid for the duration of its usage.\n @pre @p compressor must be already validated."]
    pub fn ZL_CCtx_refCompressor(cctx: *mut ZL_CCtx, compressor: *const ZL_Compressor)
        -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Set the starting Graph of next compression,\n as @p graphID referenced in the provided @p compressor,\n optionally providing it with some runtime parameters.\n @pre @p compressor must remain valid for the duration of its usage.\n @pre @p compressor must be already validated.\n\n @param cctx The active compression state\n @param compressor The reference compressor containing graph definitions.\n                   If NULL, it uses the currently registered compressor.\n @param graphID The ID of the starting graph.\n @param rgp Optional parameters to apply to the starting graph.\n            NULL means don't override.\n\n Note: like all global parameters, these parameters are reset at end of\n compression."]
    pub fn ZL_CCtx_selectStartingGraphID(
        cctx: *mut ZL_CCtx,
        compressor: *const ZL_Compressor,
        graphID: ZL_GraphID,
        rgp: *const ZL_GraphParameters,
    ) -> ZL_Report;
}
#[doc = " @brief While it's possible to add elements (graphs, selectors or nodes) to a\n Compressor one by one, and then finalize it by selecting a starting graph ID,\n it's generally common for all these steps to be regrouped into a single\n initialization function.\n The following signature corresponds such a function.\n It returns a GraphID which, by convention, is the starting GraphID."]
pub type ZL_GraphFn =
    ::std::option::Option<unsafe extern "C" fn(compressor: *mut ZL_Compressor) -> ZL_GraphID>;
extern "C" {
    #[doc = " @brief Initialize a @p compressor object with a `ZL_GraphFn` Graph function\n @p f. It will register a few custom graphs and custom nodes, and set the\n starting Graph ID. This is a convenience function, which is equivalent to\n calling the Graph function, then ZL_Compressor_selectStartingGraphID()\n followed by ZL_Compressor_validate()\n @returns Success or an error which can be checked with ZL_isError().\n @param f The function used to build the `ZL_GraphID`."]
    pub fn ZL_Compressor_initUsingGraphFn(
        compressor: *mut ZL_Compressor,
        f: ZL_GraphFn,
    ) -> ZL_Report;
}
extern "C" {
    pub fn ZL_compress_usingCompressor(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        compressor: *const ZL_Compressor,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief compresses using @param graphFunction that both defines a custom graph\n and sets global parameters."]
    pub fn ZL_compress_usingGraphFn(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        graphFunction: ZL_GraphFn,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Creates and initializes an opaque `ZL_CompressorSerializer` object.\n\n Currently, this object can only be used for a single call to @ref\n ZL_CompressorSerializer_serialize(). You need to create a new serializer\n for every serialization you want to do.\n\n This will likely be improved in the future; it shouldn't be too hard to do.\n\n @returns the created `ZL_CompressorSerializer` if successful. Otherwise,\n          returns `NULL`."]
    pub fn ZL_CompressorSerializer_create() -> *mut ZL_CompressorSerializer;
}
extern "C" {
    #[doc = " Frees all the resources owned by the @p serializer, including the @p\n serializer itself."]
    pub fn ZL_CompressorSerializer_free(serializer: *mut ZL_CompressorSerializer);
}
extern "C" {
    #[doc = " Returns a serialized representation of the given @p compressor.\n\n See the documentation above for a description of how compressors must be\n structured to be compressible.\n\n This function uses @p dst and @dstSize both as (1) input arguments that\n optionally indicate an existing buffer into which the output of the\n serialization process can be placed as well as (2) output arguments\n indicating where the output actually was placed.\n\n When @p dst points to a `void*` variable with a non-`NULL` initial value,\n and @p dstSize points to a `size_t` variable with a non-zero initial value,\n this function will attempt to write the serialized output into the buffer\n pointed to by `*dst` with capacity `*dstSize`. If the output fits in that\n provided buffer, then `*dst` will be left unchanged, and `*dstSize` will be\n updated to reflect the written size of the output.\n\n Otherwise, either because the output doesn't fit in the provided buffer or\n because no buffer was provided (`*dst` is `NULL` or `*dstSize == 0`), an\n output buffer of sufficient size to hold the output is allocated. `*dst` is\n set to point to the start of that buffer and `*dstSize` is set to the size\n of the output. That buffer is owned by @p serializer and will be freed when\n the @p serializer is destroyed.\n\n @param[in out] dst     Pointer to a variable pointing to the output buffer,\n                        which can start out either pointing to an existing\n                        output buffer or `NULL`. That variable will be set to\n                        point to the output buffer actually used.\n @param[in out] dstSize Pointer to a variable that should be initialized to\n                        the capacity of the output buffer, if one is being\n                        provided, or 0 otherwise. That variable will be set\n                        to contain the written size of the output.\n\n @returns success or an error."]
    pub fn ZL_CompressorSerializer_serialize(
        serializer: *mut ZL_CompressorSerializer,
        compressor: *const ZL_Compressor,
        dst: *mut *mut ::std::os::raw::c_void,
        dstSize: *mut usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Equivalent @ref ZL_CompressorSerializer_serialize, but produces a human-\n readable output for debugging. This output format cannot currently be\n consumed by OpenZL.\n\n The output is null-terminated."]
    pub fn ZL_CompressorSerializer_serializeToJson(
        serializer: *mut ZL_CompressorSerializer,
        compressor: *const ZL_Compressor,
        dst: *mut *mut ::std::os::raw::c_void,
        dstSize: *mut usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Converts an already-serialized compressor to human-readable JSON.\n\n The output is null-terminated.\n\n The semantics of @p dst and @p dstSize are as described with @ref\n ZL_CompressorSerializer_serialize."]
    pub fn ZL_CompressorSerializer_convertToJson(
        serializer: *mut ZL_CompressorSerializer,
        dst: *mut *mut ::std::os::raw::c_void,
        dstSize: *mut usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " Safely retrieve the full error message associated with an error.\n\n @returns the verbose error message associated with the @p result or `NULL`\n          if the error is no longer valid.\n\n @note This string is stored within the @p serializer and is only valid for\n       the lifetime of the @p serializer."]
    pub fn ZL_CompressorSerializer_getErrorContextString(
        serializer: *const ZL_CompressorSerializer,
        result: ZL_Report,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Like @ref ZL_CompressorSerializer_getErrorContextString(), but generic\n across result types. Use like:\n\n ```\n ZL_RESULT_OF(Something) result = ...;\n const char* msg = ZL_CompressorSerializer_getErrorContextString_fromError(\n     serializer, ZL_RES_error(result));\n ```\n\n @returns the verbose error message associated with the @p error or `NULL`\n          if the error is no longer valid.\n\n @note This string is stored within the @p serializer and is only valid for\n       the lifetime of the @p serializer."]
    pub fn ZL_CompressorSerializer_getErrorContextString_fromError(
        deserializer: *const ZL_CompressorSerializer,
        error: ZL_Error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates and initializes an opaque `ZL_CompressorDeserializer` object.\n\n Currently, this object can only be used for a single call to @ref\n ZL_CompressorDeserializer_deserialize(). You need to create a new\n deserializer for every deserialization you want to do.\n\n This will likely be improved in the future; it shouldn't be too hard to do.\n\n @returns the created `ZL_CompressorDeserializer` if successful. Otherwise,\n          returns `NULL`."]
    pub fn ZL_CompressorDeserializer_create() -> *mut ZL_CompressorDeserializer;
}
extern "C" {
    #[doc = " Frees all the resources owned by the @p deserializer, including the @p\n deserializer itself."]
    pub fn ZL_CompressorDeserializer_free(deserializer: *mut ZL_CompressorDeserializer);
}
extern "C" {
    #[doc = " Reads the serialized compressor represented by @p serialized and pushes\n the graph structure and configuration it describes into @p compressor.\n\n In order for materialization to succeed, the @p compressor must already have\n all of the custom transforms, graph functions, selectors, etc. registered\n that were available when the compressor was serialized. You can use @ref\n ZL_CompressorDeserializer_getDependencies() to determine what non-serialized\n graph components are needed on the destination compressor. You can then set\n those components up before invoking this operation on that compressor.\n\n See the documentation above for a more thorough discussion of these\n requirements and how best to structure a compressor to meet them.\n\n If this operation fails, the compressor may be left in an indeterminate\n state. The best thing to do is to just throw this compressor away\n (via @ref ZL_Compressor_free) and not to try to re-use it."]
    pub fn ZL_CompressorDeserializer_deserialize(
        deserializer: *mut ZL_CompressorDeserializer,
        compressor: *mut ZL_Compressor,
        serialized: *const ::std::os::raw::c_void,
        serializedSize: usize,
    ) -> ZL_Report;
}
#[doc = " Doesn't own any memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CompressorDeserializer_Dependencies {
    pub graph_names: *const *const ::std::os::raw::c_char,
    pub num_graphs: usize,
    pub node_names: *const *const ::std::os::raw::c_char,
    pub num_nodes: usize,
}
#[test]
fn bindgen_test_layout_ZL_CompressorDeserializer_Dependencies() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_CompressorDeserializer_Dependencies> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_CompressorDeserializer_Dependencies>(),
        32usize,
        "Size of ZL_CompressorDeserializer_Dependencies"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_CompressorDeserializer_Dependencies>(),
        8usize,
        "Alignment of ZL_CompressorDeserializer_Dependencies"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_names) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_CompressorDeserializer_Dependencies::graph_names"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_graphs) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_CompressorDeserializer_Dependencies::num_graphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_names) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_CompressorDeserializer_Dependencies::node_names"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_nodes) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_CompressorDeserializer_Dependencies::num_nodes"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_Result_ZL_CompressorDeserializer_Dependencies_inner {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_CompressorDeserializer_Dependencies,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_CompressorDeserializer_Dependencies_inner() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_CompressorDeserializer_Dependencies_inner> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_CompressorDeserializer_Dependencies_inner>(),
        40usize,
        "Size of ZL_Result_ZL_CompressorDeserializer_Dependencies_inner"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_CompressorDeserializer_Dependencies_inner>(),
        8usize,
        "Alignment of ZL_Result_ZL_CompressorDeserializer_Dependencies_inner"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_CompressorDeserializer_Dependencies_inner::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_Result_ZL_CompressorDeserializer_Dependencies_inner::_value"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ZL_Result_ZL_CompressorDeserializer_Dependencies_u {
    pub _code: ZL_ErrorCode,
    pub _value: ZL_Result_ZL_CompressorDeserializer_Dependencies_inner,
    pub _error: ZL_Error,
}
#[test]
fn bindgen_test_layout_ZL_Result_ZL_CompressorDeserializer_Dependencies_u() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_Result_ZL_CompressorDeserializer_Dependencies_u> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_Result_ZL_CompressorDeserializer_Dependencies_u>(),
        40usize,
        "Size of ZL_Result_ZL_CompressorDeserializer_Dependencies_u"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_Result_ZL_CompressorDeserializer_Dependencies_u>(),
        8usize,
        "Alignment of ZL_Result_ZL_CompressorDeserializer_Dependencies_u"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._code) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_CompressorDeserializer_Dependencies_u::_code"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._value) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_CompressorDeserializer_Dependencies_u::_value"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._error) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_Result_ZL_CompressorDeserializer_Dependencies_u::_error"
    );
}
pub type ZL_Result_ZL_CompressorDeserializer_Dependencies =
    ZL_Result_ZL_CompressorDeserializer_Dependencies_u;
extern "C" {
    #[link_name = "ZL_Result_ZL_CompressorDeserializer_Dependencies_extract__extern"]
    pub fn ZL_Result_ZL_CompressorDeserializer_Dependencies_extract(
        result: ZL_Result_ZL_CompressorDeserializer_Dependencies,
        error: *mut ZL_Error,
    ) -> ZL_CompressorDeserializer_Dependencies;
}
pub type ZL_Result_ZL_CompressorDeserializer_Dependencies_fake_type_needs_semicolon =
    ::std::os::raw::c_int;
extern "C" {
    #[doc = " Read the serialized compressor from @p serialized and find all of the nodes\n and graphs that the serialized compressor refers to but that aren't present\n in the serialized compressor. I.e., lists all the components that must be\n present on a destination compressor in order for this serialized compressor\n to correctly materialize onto that destination compressor.\n\n @param compressor An optional (nullable) pointer to a destination\n                   compressor. If provided, any nodes or graphs already\n                   available in that compressor will be removed from the\n                   returned dependencies, making the returned list strictly\n                   the *unmet* dependencies. Otherwise, returns all nodes and\n                   graphs referred to by the serialized compressor but not\n                   defined by the serialized compressor.\n\n @returns The lists of graph and node names which are unsatisfied\n          dependencies. The memory backing the arrays and strings is owned by\n          the @p deserializer and will be freed when the @p deserializer is\n          destroyed."]
    pub fn ZL_CompressorDeserializer_getDependencies(
        deserializer: *mut ZL_CompressorDeserializer,
        compressor: *const ZL_Compressor,
        serialized: *const ::std::os::raw::c_void,
        serializedSize: usize,
    ) -> ZL_Result_ZL_CompressorDeserializer_Dependencies;
}
extern "C" {
    #[doc = " Safely retrieve the full error message associated with an error.\n\n @returns the verbose error message associated with the @p result or `NULL`\n          if the error is no longer valid.\n\n @note This string is stored within the @p deserializer and is only valid for\n       the lifetime of the @p deserializer."]
    pub fn ZL_CompressorDeserializer_getErrorContextString(
        deserializer: *const ZL_CompressorDeserializer,
        result: ZL_Report,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Like @ref ZL_CompressorDeserializer_getErrorContextString(), but generic\n across result types. Use like:\n\n ```\n ZL_RESULT_OF(Something) result = ...;\n const char* msg = ZL_CompressorDeserializer_getErrorContextString_fromError(\n     deserializer, ZL_RES_error(result));\n ```\n\n @returns the verbose error message associated with the @p error or `NULL`\n          if the error is no longer valid.\n\n @note This string is stored within the @p deserializer and is only valid for\n       the lifetime of the @p deserializer."]
    pub fn ZL_CompressorDeserializer_getErrorContextString_fromError(
        deserializer: *const ZL_CompressorDeserializer,
        error: ZL_Error,
    ) -> *const ::std::os::raw::c_char;
}
pub type ZL_PipeDstCapacityFn = ::std::option::Option<
    unsafe extern "C" fn(src: *const ::std::os::raw::c_void, srcSize: usize) -> usize,
>;
pub type ZL_PipeEncoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> usize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_PipeEncoderDesc {
    pub CTid: ZL_IDType,
    pub transform_f: ZL_PipeEncoderFn,
    pub dstBound_f: ZL_PipeDstCapacityFn,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_PipeEncoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_PipeEncoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_PipeEncoderDesc>(),
        32usize,
        "Size of ZL_PipeEncoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_PipeEncoderDesc>(),
        8usize,
        "Alignment of ZL_PipeEncoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_PipeEncoderDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_PipeEncoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstBound_f) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_PipeEncoderDesc::dstBound_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_PipeEncoderDesc::name"
    );
}
extern "C" {
    #[doc = " Register a custom pipe encoder, to be employed in upcoming Graph.\n This registration is specialized for simple pipe transforms.\n Counterpart: ZL_DCtx_registerPipeDecoder().\n This action creates a NodeID, provided as @return value.\n Graphs using custom encoders are only decodable if,\n at decompression time, a custom decoder of same CTid is registered."]
    pub fn ZL_Compressor_registerPipeEncoder(
        cgraph: *mut ZL_Compressor,
        ctd: *const ZL_PipeEncoderDesc,
    ) -> ZL_NodeID;
}
pub type ZL_SplitEncoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        eic: *mut ZL_Encoder,
        writtenSizes: *mut usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SplitEncoderDesc {
    pub CTid: ZL_IDType,
    pub transform_f: ZL_SplitEncoderFn,
    pub nbOutputStreams: usize,
    pub localParams: ZL_LocalParams,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_SplitEncoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SplitEncoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SplitEncoderDesc>(),
        80usize,
        "Size of ZL_SplitEncoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SplitEncoderDesc>(),
        8usize,
        "Alignment of ZL_SplitEncoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SplitEncoderDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SplitEncoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbOutputStreams) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_SplitEncoderDesc::nbOutputStreams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_SplitEncoderDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        72usize,
        "Offset of field: ZL_SplitEncoderDesc::name"
    );
}
extern "C" {
    #[doc = " Register a custom Split Transform"]
    pub fn ZL_Compressor_registerSplitEncoder(
        cgraph: *mut ZL_Compressor,
        ctd: *const ZL_SplitEncoderDesc,
    ) -> ZL_NodeID;
}
extern "C" {
    pub fn ZL_Encoder_createAllOutBuffers(
        eic: *mut ZL_Encoder,
        buffStarts: *mut *mut ::std::os::raw::c_void,
        buffCapacities: *const usize,
        nbBuffs: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[link_name = "ZL_codemodOutputAsData__extern"]
    pub fn ZL_codemodOutputAsData(output: *mut ZL_Output) -> *mut ZL_Data;
}
extern "C" {
    #[link_name = "ZL_codemodDataAsOutput__extern"]
    pub fn ZL_codemodDataAsOutput(data: *mut ZL_Data) -> *mut ZL_Output;
}
extern "C" {
    #[link_name = "ZL_codemodConstOutputAsData__extern"]
    pub fn ZL_codemodConstOutputAsData(output: *const ZL_Output) -> *const ZL_Data;
}
extern "C" {
    #[link_name = "ZL_codemodConstDataAsOutput__extern"]
    pub fn ZL_codemodConstDataAsOutput(data: *const ZL_Data) -> *const ZL_Output;
}
extern "C" {
    #[link_name = "ZL_codemodConstDatasAsOutputs__extern"]
    pub fn ZL_codemodConstDatasAsOutputs(datas: *mut *const ZL_Data) -> *mut *const ZL_Output;
}
extern "C" {
    #[link_name = "ZL_codemodOutputsAsDatas__extern"]
    pub fn ZL_codemodOutputsAsDatas(outputs: *mut *mut ZL_Output) -> *mut *mut ZL_Data;
}
extern "C" {
    #[link_name = "ZL_Output_type__extern"]
    pub fn ZL_Output_type(output: *const ZL_Output) -> ZL_Type;
}
extern "C" {
    #[link_name = "ZL_Output_id__extern"]
    pub fn ZL_Output_id(output: *const ZL_Output) -> ZL_DataID;
}
extern "C" {
    #[doc = " @returns The element width of the @p output if it has a buffer reserved,\n otherwise it returns NULL. Within a custom codec, this function always\n succeeds, because the output always has a buffer reserved. If the type\n of the output is String, it returns 0 instead."]
    pub fn ZL_Output_eltWidth(output: *const ZL_Output) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The number of elements committed in @p output if it has been\n committed. Otherwise, returns an error if the write to @p output has not been\n committed."]
    pub fn ZL_Output_numElts(output: *const ZL_Output) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The content size in bytes that has been committed to @p output.\n For non-string types, this is the eltWidth * numElts. For string types, this\n is the sum of the lengths of each stream. If @p output has not been commited,\n it returns an error."]
    pub fn ZL_Output_contentSize(output: *const ZL_Output) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The capacity of the buffer reserved for @p output in number of\n elements. If @p output has not been reserved, it returns an error.\n For string types, this is the number of strings that can be written into the\n buffer."]
    pub fn ZL_Output_eltsCapacity(output: *const ZL_Output) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The capacity of the buffer reserved for @p output in bytes. If\n @p output has not been reserved, it returns an error. For string types, this\n is the sum of the lengths of each string that can be written into the buffer."]
    pub fn ZL_Output_contentCapacity(output: *const ZL_Output) -> ZL_Report;
}
extern "C" {
    #[doc = " These methods provide direct access to internal buffer.\n Warning : users must pay attention to buffer boundaries.\n @return pointer to buffer position to resume writing.\n @note for `ZL_Type_string`, returns a pointer to the buffer containing the\n concatenated strings."]
    #[link_name = "ZL_Output_ptr__extern"]
    pub fn ZL_Output_ptr(output: *mut ZL_Output) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns a const pointer to the _beginning_ of the buffer.\n It returns NULL if the output does not have a buffer attached to it yet.\n This cannot happen within a custom codec.\n Warning : users must pay attention to buffer boundaries.\n @note for `ZL_Type_string`, returns a pointer to the buffer containing the\n concatenated strings."]
    #[link_name = "ZL_Output_constPtr__extern"]
    pub fn ZL_Output_constPtr(output: *const ZL_Output) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n It requests write access into StringLens array.\n Only valid if StringLens array has already been allocated.\n @return pointer to array position to resume writing.\n or NULL if any of above conditions is violated.\n\n Array's capacity is supposed known from reservation request.\n After writing into the array, the nb of Strings, which is also\n the nb of String Lengths written, must be provided using\n ZL_Data_commit()."]
    #[link_name = "ZL_Output_stringLens__extern"]
    pub fn ZL_Output_stringLens(output: *mut ZL_Output) -> *mut u32;
}
extern "C" {
    #[doc = " @returns A const pointer to the array containing lengths for string-typed\n outputs. It returns NULL if the output is not of type string."]
    #[link_name = "ZL_Output_constStringLens__extern"]
    pub fn ZL_Output_constStringLens(output: *const ZL_Output) -> *const u32;
}
extern "C" {
    #[doc = " This method is only valid for `ZL_Type_string` Data.\n It reserves memory space for StringLens array, and returns a pointer to it.\n The buffer is owned by @p data and has the same lifetime.\n The returned pointer can be used to write into the array.\n After writing into the array, the nb of String Lengths provided must be\n signaled using @ref ZL_Output_commit().\n This method will fail if StringLens is already allocated.\n @return `NULL` if incorrect data type, or allocation error."]
    #[link_name = "ZL_Output_reserveStringLens__extern"]
    pub fn ZL_Output_reserveStringLens(output: *mut ZL_Output, numStrings: usize) -> *mut u32;
}
extern "C" {
    #[doc = " @brief Commit the number of elements written into @p data.\n\n This method must be called exactly once for every output.\n The @p nbElts must be `<=` reserved capacity of @p data.\n Note that, for `ZL_Type_string`, this is the number of strings written into\n@p data.\n The operation will automatically determine the total size of all Strings\nwithin @p data.\n\n @returns Success or an error. This function will fail if it is called more\n than once on the same @p data, or if @p nbElts is greater than @p data's\n capacity.\n\n Terminating a Codec _without_ committing anything to @p data (not even `0`)\n is considered an error, that is caught by the Engine\n (classified as node processing error).\n\n @note @p nbElts, as \"number of elements\", is **not** the same as size in\nbytes written in\n the buffer. For Numerics and Structs, the translation is\n straighforward. For Strings, the field sizes array must be\n provided first, using `ZL_Data_reserveStringLens()` to create\n and access the array. The resulting useful content size will then\n be calculated from the sum of field sizes. It will be controlled,\n and there will be an error if sum(sizes) > bufferCapacity."]
    #[link_name = "ZL_Output_commit__extern"]
    pub fn ZL_Output_commit(output: *mut ZL_Output, numElts: usize) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Sets integer metadata with the key @p key and value @p value on the\n stream.\n\n It is only valid to call ZL_Data_setIntMetadata() with the same @p key\n once. Subsequent calls with the same @p key will return an error.\n\n @param key Metdata key\n @param value Metadata value\n\n @returns Success or an error. This function will fail due to repeated calls\n with the same @p key, or upon running out of space for the metadata.\n\n @note In this proposed design, Int Metadata are set one by one.\n Another possible design could follow the IntParams\n model, where all parameters must be set all-at-once, and be\n provided as a single vector of IntParams structures.\n\n @note The set value is an int, hence it's not suitable to store \"large\"\n values, like 64-bit ULL."]
    #[link_name = "ZL_Output_setIntMetadata__extern"]
    pub fn ZL_Output_setIntMetadata(
        output: *mut ZL_Output,
        key: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The value if present. ZL_IntMetadata::isPresent != 0\n when the @p key exists, in which case ZL_IntMetadata::mValue is set to the\n value."]
    #[link_name = "ZL_Output_getIntMetadata__extern"]
    pub fn ZL_Output_getIntMetadata(
        output: *const ZL_Output,
        key: ::std::os::raw::c_int,
    ) -> ZL_IntMetadata;
}
pub type ZL_SerialSelectorFn = ::std::option::Option<
    unsafe extern "C" fn(
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        customGraphs: *const ZL_GraphID,
        nbCustomGraphs: usize,
    ) -> ZL_GraphID,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SerialSelectorDesc {
    pub selector_f: ZL_SerialSelectorFn,
    pub customGraphs: *const ZL_GraphID,
    pub nbCustomGraphs: usize,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_SerialSelectorDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SerialSelectorDesc> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SerialSelectorDesc>(),
        32usize,
        "Size of ZL_SerialSelectorDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SerialSelectorDesc>(),
        8usize,
        "Alignment of ZL_SerialSelectorDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selector_f) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SerialSelectorDesc::selector_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customGraphs) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SerialSelectorDesc::customGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomGraphs) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_SerialSelectorDesc::nbCustomGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_SerialSelectorDesc::name"
    );
}
extern "C" {
    pub fn ZL_Compressor_registerSerialSelectorGraph(
        cgraph: *mut ZL_Compressor,
        csd: *const ZL_SerialSelectorDesc,
    ) -> ZL_GraphID;
}
pub type ZL_SelectorFn = ::std::option::Option<
    unsafe extern "C" fn(
        selectorAPI: *const ZL_Selector,
        input: *const ZL_Input,
        customGraphs: *const ZL_GraphID,
        nbCustomGraphs: usize,
    ) -> ZL_GraphID,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SelectorDesc {
    pub selector_f: ZL_SelectorFn,
    #[doc = " Selectors optionally support multiple input types,\n using bitmap masking (ex: ZL_Type_struct | ZL_Type_string).\n In which case, it's the responsibility of the selector to select\n a successor featuring an input type compatible with current input.\n Note that it's always preferable to limit Selector's input type\n to the minimum nb of types possible,\n because it makes graph validation more accurate and effective."]
    pub inStreamType: ZL_Type,
    pub customGraphs: *const ZL_GraphID,
    pub nbCustomGraphs: usize,
    pub localParams: ZL_LocalParams,
    #[doc = " Optional, the name of the graph rooted by the selector."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Selector_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the compressor."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_SelectorDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SelectorDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SelectorDesc>(),
        112usize,
        "Size of ZL_SelectorDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SelectorDesc>(),
        8usize,
        "Alignment of ZL_SelectorDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).selector_f) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SelectorDesc::selector_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inStreamType) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SelectorDesc::inStreamType"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customGraphs) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_SelectorDesc::customGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbCustomGraphs) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_SelectorDesc::nbCustomGraphs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_SelectorDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_SelectorDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        88usize,
        "Offset of field: ZL_SelectorDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a selector graph given the @p desc.\n\n @note This is a new variant of @ref ZL_Compressor_registerSelectorGraph that\n reports errors using OpenZL's ZL_Report error system.\n\n @param desc The description of the selector, must be non-null.\n\n @return The new graph ID, or an error."]
    pub fn ZL_Compressor_registerSelectorGraph2(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_SelectorDesc,
    ) -> ZL_Result_ZL_GraphID;
}
extern "C" {
    pub fn ZL_Compressor_registerSelectorGraph(
        cgraph: *mut ZL_Compressor,
        ctsd: *const ZL_SelectorDesc,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " Utility function to get the input types supported by @gid as an input mask.\n Throws an error if @gid is not valid or does not have exactly one input.\n See ZL_Compressor_Graph_getInput0Mask() for more details."]
    pub fn ZL_Selector_getInput0MaskForGraph(
        selCtx: *const ZL_Selector,
        gid: ZL_GraphID,
    ) -> ZL_Type;
}
extern "C" {
    pub fn ZL_Selector_getOpaquePtr(selector: *const ZL_Selector) -> *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ZL_GraphReport {
    pub finalCompressedSize: ZL_Report,
}
#[test]
fn bindgen_test_layout_ZL_GraphReport() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_GraphReport> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_GraphReport>(),
        16usize,
        "Size of ZL_GraphReport"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_GraphReport>(),
        8usize,
        "Alignment of ZL_GraphReport"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalCompressedSize) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_GraphReport::finalCompressedSize"
    );
}
extern "C" {
    pub fn ZL_Selector_tryGraph(
        selCtx: *const ZL_Selector,
        input: *const ZL_Input,
        graphid: ZL_GraphID,
    ) -> ZL_GraphReport;
}
extern "C" {
    pub fn ZL_Selector_setSuccessorParams(
        selCtx: *const ZL_Selector,
        lparams: *const ZL_LocalParams,
    ) -> ZL_Report;
}
extern "C" {
    pub fn ZL_Selector_getCParam(
        selCtx: *const ZL_Selector,
        gparam: ZL_CParam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ZL_Selector_getLocalIntParam(
        selCtx: *const ZL_Selector,
        intParamId: ::std::os::raw::c_int,
    ) -> ZL_IntParam;
}
extern "C" {
    pub fn ZL_Selector_getLocalParam(
        selCtx: *const ZL_Selector,
        paramId: ::std::os::raw::c_int,
    ) -> ZL_RefParam;
}
extern "C" {
    pub fn ZL_Selector_getLocalCopyParam(
        selCtx: *const ZL_Selector,
        copyParamId: ::std::os::raw::c_int,
    ) -> ZL_CopyParam;
}
extern "C" {
    pub fn ZL_Selector_getLocalIntParams(selCtx: *const ZL_Selector) -> ZL_LocalIntParams;
}
extern "C" {
    pub fn ZL_Selector_getScratchSpace(
        selCtx: *const ZL_Selector,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type ZL_CodecStateAlloc =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
pub type ZL_CodecStateFree =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CodecStateManager {
    pub stateAlloc: ZL_CodecStateAlloc,
    pub stateFree: ZL_CodecStateFree,
    pub optionalStateID: usize,
}
#[test]
fn bindgen_test_layout_ZL_CodecStateManager() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_CodecStateManager> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_CodecStateManager>(),
        24usize,
        "Size of ZL_CodecStateManager"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_CodecStateManager>(),
        8usize,
        "Alignment of ZL_CodecStateManager"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateAlloc) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_CodecStateManager::stateAlloc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateFree) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_CodecStateManager::stateFree"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optionalStateID) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_CodecStateManager::optionalStateID"
    );
}
pub type ZL_TypedEncoderFn = ::std::option::Option<
    unsafe extern "C" fn(ectx: *mut ZL_Encoder, in_: *const ZL_Input) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_TypedGraphDesc {
    pub CTid: ZL_IDType,
    pub inStreamType: ZL_Type,
    pub outStreamTypes: *const ZL_Type,
    pub nbOutStreams: usize,
}
#[test]
fn bindgen_test_layout_ZL_TypedGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_TypedGraphDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_TypedGraphDesc>(),
        24usize,
        "Size of ZL_TypedGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_TypedGraphDesc>(),
        8usize,
        "Alignment of ZL_TypedGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_TypedGraphDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inStreamType) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_TypedGraphDesc::inStreamType"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outStreamTypes) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_TypedGraphDesc::outStreamTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbOutStreams) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_TypedGraphDesc::nbOutStreams"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_TypedEncoderDesc {
    pub gd: ZL_TypedGraphDesc,
    pub transform_f: ZL_TypedEncoderFn,
    pub localParams: ZL_LocalParams,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Encoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the compressor."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_TypedEncoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_TypedEncoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_TypedEncoderDesc>(),
        136usize,
        "Size of ZL_TypedEncoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_TypedEncoderDesc>(),
        8usize,
        "Alignment of ZL_TypedEncoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_TypedEncoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_TypedEncoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_TypedEncoderDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_TypedEncoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        88usize,
        "Offset of field: ZL_TypedEncoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        112usize,
        "Offset of field: ZL_TypedEncoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a custom encoder that can be used to compress.\n\n @note This is a new variant of @ref ZL_Compressor_registerTypedEncoder that\n reports errors using OpenZL's ZL_Report error system.\n\n @warning Using a custom encoder requires the decoder to be registered before\n decompression.\n\n @param desc The description of the encoder.\n\n @returns The new node ID, or an error."]
    pub fn ZL_Compressor_registerTypedEncoder2(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_TypedEncoderDesc,
    ) -> ZL_Result_ZL_NodeID;
}
extern "C" {
    #[doc = " Register a custom Typed Transform, to be employed in upcoming graph."]
    pub fn ZL_Compressor_registerTypedEncoder(
        cgraph: *mut ZL_Compressor,
        ctd: *const ZL_TypedEncoderDesc,
    ) -> ZL_NodeID;
}
pub type ZL_VOEncoderFn = ::std::option::Option<
    unsafe extern "C" fn(ectx: *mut ZL_Encoder, in_: *const ZL_Input) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_VOGraphDesc {
    pub CTid: ZL_IDType,
    pub inStreamType: ZL_Type,
    pub singletonTypes: *const ZL_Type,
    pub nbSingletons: usize,
    pub voTypes: *const ZL_Type,
    pub nbVOs: usize,
}
#[test]
fn bindgen_test_layout_ZL_VOGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_VOGraphDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_VOGraphDesc>(),
        40usize,
        "Size of ZL_VOGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_VOGraphDesc>(),
        8usize,
        "Alignment of ZL_VOGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_VOGraphDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inStreamType) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_VOGraphDesc::inStreamType"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singletonTypes) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_VOGraphDesc::singletonTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbSingletons) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_VOGraphDesc::nbSingletons"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voTypes) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_VOGraphDesc::voTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbVOs) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_VOGraphDesc::nbVOs"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_VOEncoderDesc {
    pub gd: ZL_VOGraphDesc,
    pub transform_f: ZL_VOEncoderFn,
    pub localParams: ZL_LocalParams,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Encoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the compressor."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_VOEncoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_VOEncoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_VOEncoderDesc>(),
        152usize,
        "Size of ZL_VOEncoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_VOEncoderDesc>(),
        8usize,
        "Alignment of ZL_VOEncoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_VOEncoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_VOEncoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_VOEncoderDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        96usize,
        "Offset of field: ZL_VOEncoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        104usize,
        "Offset of field: ZL_VOEncoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        128usize,
        "Offset of field: ZL_VOEncoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a custom encoder that can be used to compress.\n\n @note This is a new variant of @ref ZL_Compressor_registerVOEncoder that\n reports errors using OpenZL's ZL_Report error system.\n\n @warning Using a custom encoder requires the decoder to be registered before\n decompression.\n\n @param desc The description of the encoder.\n\n @returns The new node ID, or an error."]
    pub fn ZL_Compressor_registerVOEncoder2(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_VOEncoderDesc,
    ) -> ZL_Result_ZL_NodeID;
}
extern "C" {
    pub fn ZL_Compressor_registerVOEncoder(
        cgraph: *mut ZL_Compressor,
        ctd: *const ZL_VOEncoderDesc,
    ) -> ZL_NodeID;
}
pub type ZL_MIEncoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        eictx: *mut ZL_Encoder,
        inputs: *mut *const ZL_Input,
        nbInputs: usize,
    ) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_MIGraphDesc {
    pub CTid: ZL_IDType,
    pub inputTypes: *const ZL_Type,
    pub nbInputs: usize,
    pub lastInputIsVariable: ::std::os::raw::c_int,
    pub soTypes: *const ZL_Type,
    pub nbSOs: usize,
    pub voTypes: *const ZL_Type,
    pub nbVOs: usize,
}
#[test]
fn bindgen_test_layout_ZL_MIGraphDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_MIGraphDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_MIGraphDesc>(),
        64usize,
        "Size of ZL_MIGraphDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_MIGraphDesc>(),
        8usize,
        "Alignment of ZL_MIGraphDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_MIGraphDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputTypes) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_MIGraphDesc::inputTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbInputs) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_MIGraphDesc::nbInputs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastInputIsVariable) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_MIGraphDesc::lastInputIsVariable"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soTypes) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_MIGraphDesc::soTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbSOs) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_MIGraphDesc::nbSOs"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voTypes) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_MIGraphDesc::voTypes"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbVOs) as usize - ptr as usize },
        56usize,
        "Offset of field: ZL_MIGraphDesc::nbVOs"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_MIEncoderDesc {
    pub gd: ZL_MIGraphDesc,
    pub transform_f: ZL_MIEncoderFn,
    pub localParams: ZL_LocalParams,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Encoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the compressor."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_MIEncoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_MIEncoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_MIEncoderDesc>(),
        176usize,
        "Size of ZL_MIEncoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_MIEncoderDesc>(),
        8usize,
        "Alignment of ZL_MIEncoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_MIEncoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        64usize,
        "Offset of field: ZL_MIEncoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localParams) as usize - ptr as usize },
        72usize,
        "Offset of field: ZL_MIEncoderDesc::localParams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        120usize,
        "Offset of field: ZL_MIEncoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        128usize,
        "Offset of field: ZL_MIEncoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        152usize,
        "Offset of field: ZL_MIEncoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a custom encoder that can be used to compress.\n\n @note This is a new variant of @ref ZL_Compressor_registerMIEncoder that\n reports errors using OpenZL's ZL_Report error system.\n\n @warning Using a custom encoder requires the decoder to be registered before\n decompression.\n\n @param desc The description of the encoder.\n\n @returns The new node ID, or an error."]
    pub fn ZL_Compressor_registerMIEncoder2(
        compressor: *mut ZL_Compressor,
        desc: *const ZL_MIEncoderDesc,
    ) -> ZL_Result_ZL_NodeID;
}
extern "C" {
    pub fn ZL_Compressor_registerMIEncoder(
        cgraph: *mut ZL_Compressor,
        ctd: *const ZL_MIEncoderDesc,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " Registration might fail, for example if the Descriptor is incorrectly filled.\n In which case, the returned nodeid is ZL_NODE_ILLEGAL.\n Any further operation attempted with such a Node will also fail.\n Such an outcome can be tested with ZL_NodeID_isValid().\n Note: this is mostly for debugging,\n once a Descriptor is valid, registration can be assumed to remain successful."]
    pub fn ZL_NodeID_isValid(nodeid: ZL_NodeID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ZL_Encoder_getCParam(eic: *const ZL_Encoder, gparam: ZL_CParam)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ZL_Encoder_getLocalIntParam(
        eic: *const ZL_Encoder,
        intParamId: ::std::os::raw::c_int,
    ) -> ZL_IntParam;
}
extern "C" {
    pub fn ZL_Encoder_getLocalParam(
        eic: *const ZL_Encoder,
        paramId: ::std::os::raw::c_int,
    ) -> ZL_RefParam;
}
extern "C" {
    pub fn ZL_Encoder_getLocalCopyParam(
        eic: *const ZL_Encoder,
        copyParamId: ::std::os::raw::c_int,
    ) -> ZL_CopyParam;
}
extern "C" {
    pub fn ZL_Encoder_getLocalIntParams(eic: *const ZL_Encoder) -> ZL_LocalIntParams;
}
extern "C" {
    pub fn ZL_Encoder_getLocalParams(eic: *const ZL_Encoder) -> *const ZL_LocalParams;
}
extern "C" {
    pub fn ZL_Encoder_getScratchSpace(
        eic: *mut ZL_Encoder,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_Encoder_createTypedStream(
        eic: *mut ZL_Encoder,
        outcomeIndex: ::std::os::raw::c_int,
        eltsCapacity: usize,
        eltWidth: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Encoder_createStringStream(
        eic: *mut ZL_Encoder,
        outcomeIndex: ::std::os::raw::c_int,
        nbStringsMax: usize,
        sumStringLensMax: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Encoder_sendCodecHeader(
        ei: *mut ZL_Encoder,
        trh: *const ::std::os::raw::c_void,
        trhSize: usize,
    );
}
extern "C" {
    #[doc = " @returns Returns a state, as generated by the Transform's State Manager.\n The state's lifetime is managed by the host CCtx, it will be free\n automatically at end of CCtx lifetime (and can't be forcefully free\n manually). The state may be cached from a previous run with a compatible\n transform (same state signature)."]
    pub fn ZL_Encoder_getState(ei: *mut ZL_Encoder) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns The opaque pointer provided in the transform description.\n @warning Usage of the opaque pointer must be thread-safe, and must\n not not modify the state in any way that impacts encoding!"]
    pub fn ZL_Encoder_getOpaquePtr(eictx: *const ZL_Encoder) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Decompresses a frame hosting a single serialized output.\n\n @param dst Destination buffer for decompressed data\n @param dstCapacity Size of destination buffer in bytes\n @param src Source compressed data\n @param srcSize Size of source data in bytes\n @return Either an error (check with ZL_isError()) or decompressed size on\n success"]
    pub fn ZL_decompress(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the decompressed size of content from a single-output frame.\n\n Useful to determine the size of buffer to allocate.\n\n @param compressed Pointer to compressed data\n @param cSize Size of compressed frame\nor at a minimum the size of the complete frame header\n @return Decompressed size in bytes, or error code\n\n @note Huge content sizes (> 4 GB) can't be represented on 32-bit systems\n @note For String type, @return size of all strings concatenated"]
    pub fn ZL_getDecompressedSize(
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the size of the compressed frame.\n        This method could be useful when the compressed frame only represents\n        a first portion of a larger buffer.\n\n @param compressed Pointer to compressed data.\n                   Must point at the start of a compressed frame.\n @param testedSize Size of data @p compressed points to.\n        To be useful, at a minimum, this size must be:\n        - frame header + chunk  header for version < ZL_CHUNK_VERSION_MIN.\n        - >= compressedSize for frames of versions >= ZL_CHUNK_VERSION_MIN.\n @return Compressed frame size in bytes, or error code\n\n @note Huge content sizes (> 4 GB) can't be represented on 32-bit systems"]
    pub fn ZL_getCompressedSize(
        compressed: *const ::std::os::raw::c_void,
        testedSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Creates a new decompression context.\n\n @return Pointer to new context, or NULL on error"]
    pub fn ZL_DCtx_create() -> *mut ZL_DCtx;
}
extern "C" {
    #[doc = " @brief Frees a decompression context.\n\n @param dctx Decompression context to free"]
    pub fn ZL_DCtx_free(dctx: *mut ZL_DCtx);
}
#[doc = " @brief Keep parameters across decompression sessions.\n\n By default, parameters are reset between decompression sessions.\n Setting this parameter to 1 keeps the parameters across sessions."]
pub const ZL_DParam_stickyParameters: ZL_DParam = 1;
#[doc = " @brief Enable checking the checksum of the compressed frame.\n\n The following two parameters control whether checksums are checked during\n decompression. These checks can be disabled to achieve faster speeds in\n exchange for the risk of data corruption going unnoticed.\n\n Disabling these checks is more effective when decompression speed is\n already fast. Expected improvements: ~20-30% for speeds > 2GB/s, 10-15%\n for speeds between 1GB/s and 2GB/s, and 1-5% for speeds < 1GB/s.\n\n Valid values use the ZS2_GPARAM_* format.\n @note Default 0 currently means check the checksum, might change in\n future"]
pub const ZL_DParam_checkCompressedChecksum: ZL_DParam = 2;
#[doc = " @brief Enable checking the checksum of the uncompressed content.\n\n Valid values use the ZS2_GPARAM_* format.\n @note Default 0 currently means check the checksum, might change in\n future"]
pub const ZL_DParam_checkContentChecksum: ZL_DParam = 3;
#[doc = " @brief Global decompression parameters."]
pub type ZL_DParam = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Sets global parameters via the decompression context.\n\n @param dctx Decompression context\n @param gdparam Parameter to set\n @param value Value to set for the parameter\n @return Error code or success\n\n @note By default, parameters are reset at end of decompression session.\n       To preserve them across sessions, set stickyParameters=1"]
    pub fn ZL_DCtx_setParameter(
        dctx: *mut ZL_DCtx,
        gdparam: ZL_DParam,
        value: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Reads a parameter's configured value in the decompression context.\n\n @param dctx Decompression context\n @param gdparam Parameter to query\n @return The value set for the given parameter, or 0 if unset/nonexistent"]
    pub fn ZL_DCtx_getParameter(dctx: *const ZL_DCtx, gdparam: ZL_DParam) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Resets parameters selection from a blank slate.\n\n Useful when unsure if ZL_DParam_stickyParameters is set to 1.\n\n @param dctx Decompression context\n @return Error code or success"]
    pub fn ZL_DCtx_resetParameters(dctx: *mut ZL_DCtx) -> ZL_Report;
}
extern "C" {
    pub fn ZL_DCtx_setStreamArena(dctx: *mut ZL_DCtx, sat: ZL_DataArenaType) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets a verbose error string containing context about the error.\n\n Useful for debugging and submitting bug reports to OpenZL developers.\n\n @param dctx Decompression context\n @param report Error report to get context for\n @return Error context string\n\n @note String is stored within the dctx and is only valid for the lifetime of\n the dctx"]
    pub fn ZL_DCtx_getErrorContextString(
        dctx: *const ZL_DCtx,
        report: ZL_Report,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets error context string from error code.\n\n @param dctx Decompression context\n @param error Error code to get context for\n @return Error context string\n\n @note String is stored within the dctx and is only valid for the lifetime of\n the dctx"]
    pub fn ZL_DCtx_getErrorContextString_fromError(
        dctx: *const ZL_DCtx,
        error: ZL_Error,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Gets the array of warnings from the previous operation.\n\n @param dctx Decompression context\n @return Array of warnings encountered during the previous operation\n\n @note Array and errors' lifetimes are valid until the next non-const call on\n the DCtx"]
    pub fn ZL_DCtx_getWarnings(dctx: *const ZL_DCtx) -> ZL_Error_Array;
}
extern "C" {
    #[doc = " @brief Decompresses data with explicit state management.\n\n Same as ZL_decompress(), but with explicit state management.\n The state can be used to store advanced parameters.\n\n @param dctx Decompression context\n @param dst Destination buffer for decompressed data\n @param dstCapacity Size of destination buffer in bytes\n @param compressed Source compressed data\n @param cSize Size of compressed data in bytes\n @return Error code or decompressed size on success"]
    pub fn ZL_DCtx_decompress(
        dctx: *mut ZL_DCtx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the number of outputs stored in a compressed frame.\n\n Doesn't need the whole frame, just enough to read the requested information.\n\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data\n @return Number of outputs, or error on failure (invalid frame, size too\n small, etc.)"]
    pub fn ZL_getNumOutputs(compressed: *const ::std::os::raw::c_void, cSize: usize) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the output type for single-output frames.\n\n Only works for single-output frames. Provides the type of the single output.\n\n @param stPtr Pointer to store the output type\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data\n @return Error code or success\n\n @note Only works for single-output frames"]
    pub fn ZL_getOutputType(
        stPtr: *mut ZL_Type,
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_FrameInfo {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a frame information object from compressed data.\n\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data\n @return Pointer to frame info object, or NULL on error"]
    pub fn ZL_FrameInfo_create(
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> *mut ZL_FrameInfo;
}
extern "C" {
    #[doc = " @brief Frees a frame information object.\n\n @param fi Frame information object to free"]
    pub fn ZL_FrameInfo_free(fi: *mut ZL_FrameInfo);
}
extern "C" {
    #[doc = " @brief Gets the format version of the frame.\n\n @param fi Frame information object\n @return The version number, or error if unsupported or invalid"]
    pub fn ZL_FrameInfo_getFormatVersion(fi: *const ZL_FrameInfo) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the number of regenerated outputs on decompression.\n\n @param fi Frame information object\n @return The number of outputs on decompression"]
    pub fn ZL_FrameInfo_getNumOutputs(fi: *const ZL_FrameInfo) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the output type for a specific output ID.\n\n @param fi Frame information object\n @param outputID Output ID (starts at 0, single output has ID 0)\n @return Output type, or error code"]
    pub fn ZL_FrameInfo_getOutputType(
        fi: *const ZL_FrameInfo,
        outputID: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the decompressed size of a specific output.\n\n @param fi Frame information object\n @param outputID Output ID (starts at 0)\n @return Size of specified output in bytes, or error code"]
    pub fn ZL_FrameInfo_getDecompressedSize(
        fi: *const ZL_FrameInfo,
        outputID: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the number of elements in a specific output.\n\n @param fi Frame information object\n @param outputID Output ID (starts at 0)\n @return Number of elements in specified output, or error code"]
    pub fn ZL_FrameInfo_getNumElts(
        fi: *const ZL_FrameInfo,
        outputID: ::std::os::raw::c_int,
    ) -> ZL_Report;
}
#[doc = " @brief Information about a decompressed typed output."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_OutputInfo {
    #[doc = "< Type of the output"]
    pub type_: ZL_Type,
    #[doc = "< width of elements in bytes"]
    pub fixedWidth: u32,
    #[doc = "< Decompressed size in bytes"]
    pub decompressedByteSize: u64,
    #[doc = "< Number of elements"]
    pub numElts: u64,
}
#[test]
fn bindgen_test_layout_ZL_OutputInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_OutputInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_OutputInfo>(),
        24usize,
        "Size of ZL_OutputInfo"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_OutputInfo>(),
        8usize,
        "Alignment of ZL_OutputInfo"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_OutputInfo::type_"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixedWidth) as usize - ptr as usize },
        4usize,
        "Offset of field: ZL_OutputInfo::fixedWidth"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decompressedByteSize) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_OutputInfo::decompressedByteSize"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numElts) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_OutputInfo::numElts"
    );
}
extern "C" {
    #[doc = " @brief Decompresses typed content from frames with a single typed output\n        into a pre-allocated buffer @p dst .\n        Information about output type is written into @p outputInfo .\n\n @param dctx Decompression context\n @param outputInfo Output metadata filled on success\n @param dst Destination buffer (must be large enough)\n @param dstByteCapacity Size of destination buffer in bytes\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data in bytes\n @return Error code or success\n\n @note Only works for frames with a single typed output,\n       and even then, does not work for String type.\n @note For Numeric type, dst must be correctly aligned (if unknown, assume\n 64-bit numeric)\n @note Numeric values are written using host's endianness\n @note On error, @p outputInfo content is undefined and should not be read"]
    pub fn ZL_DCtx_decompressTyped(
        dctx: *mut ZL_DCtx,
        outputInfo: *mut ZL_OutputInfo,
        dst: *mut ::std::os::raw::c_void,
        dstByteCapacity: usize,
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
#[doc = " @brief Typed buffer object that can own and auto-size their buffers.\n\n TypedBuffer uses standard C malloc/free to allocate buffers.\n Future versions could allow insertion of a custom allocator."]
pub type ZL_TypedBuffer = ZL_Output;
extern "C" {
    #[doc = " @brief Creates an empty typed buffer object.\n\n On creation, the TypedBuffer object is empty.\n By default, when provided as an empty shell,\n it will automatically allocate and fill its own buffer\n during invocation of ZL_DCtx_decompressTBuffer().\n A TypedBuffer object is not reusable and must be freed after usage.\n Releasing the object also releases its owned buffers.\n\n @return Pointer to new typed buffer, or NULL on error"]
    pub fn ZL_TypedBuffer_create() -> *mut ZL_TypedBuffer;
}
extern "C" {
    #[doc = " @brief Frees a typed buffer object.\n\n @param tbuffer Typed buffer to free"]
    pub fn ZL_TypedBuffer_free(tbuffer: *mut ZL_TypedBuffer);
}
extern "C" {
    #[doc = " @brief Creates a pre-allocated typed buffer for serial data.\n\n The object will use the referenced buffer, and not allocate its own one.\n It will be filled during invocation of ZL_DCtx_decompressTBuffer().\n Releasing the ZL_TypedBuffer object will not release the referenced buffer.\n\n @param buffer buffer to write into\n @param bufferCapacity maximum size to write into buffer\n @return Pointer to wrapped typed buffer, or NULL on error"]
    pub fn ZL_TypedBuffer_createWrapSerial(
        buffer: *mut ::std::os::raw::c_void,
        bufferCapacity: usize,
    ) -> *mut ZL_TypedBuffer;
}
extern "C" {
    #[doc = " @brief Creates a pre-allocated typed buffer for struct data.\n\n @param structBuffer buffer to write struct into.\n        Its size must be at least @p structWidth * @p structCapacity\n @param structWidth Width of each struct in bytes\n @param structCapacity Maximum number of struct that can be written into @p\n structBuffer\n @return Pointer to wrapped typed buffer, or NULL on error"]
    pub fn ZL_TypedBuffer_createWrapStruct(
        structBuffer: *mut ::std::os::raw::c_void,
        structWidth: usize,
        numStructs: usize,
    ) -> *mut ZL_TypedBuffer;
}
extern "C" {
    #[doc = " @brief Creates a pre-allocated typed buffer for numeric data.\n\n @param numArray buffer to write the array of numeric values into\n        The array size must be >= @p numWidth * @p numCapacity.\n        It must also be correctly aligned for the numeric width requested.\n @param numWidth Width of numeric values in bytes\n @param numCapacity Maximum number of numeric value that can be written into\n @p numArray\n @return Pointer to wrapped typed buffer, or NULL on error"]
    pub fn ZL_TypedBuffer_createWrapNumeric(
        numArray: *mut ::std::os::raw::c_void,
        numWidth: usize,
        numCapacity: usize,
    ) -> *mut ZL_TypedBuffer;
}
extern "C" {
    #[doc = " @brief Creates a pre-allocated ZL_TypedBuffer for String data.\n\n @param stringBuffer The buffer where the concatenation of all Strings will be\n written.\n @param stringBufferCapacity Size of stringBuffer\n @param lenBuffer Buffer for the array of lengths, which are 32-bit unsigned.\n @param maxNumStrings Maximum number of strings that can be written.\n @return Pointer to wrapped typed buffer, or NULL on error"]
    pub fn ZL_TypedBuffer_createWrapString(
        stringBuffer: *mut ::std::os::raw::c_void,
        stringBufferCapacity: usize,
        lenBuffer: *mut u32,
        maxNumStrings: usize,
    ) -> *mut ZL_TypedBuffer;
}
extern "C" {
    #[doc = " @brief Decompresses a frame with a single typed output into a TypedBuffer.\n\n This prototype works for frames with a single typed output only.\n Data will be decompressed into the output buffer.\n\n @param dctx Decompression context\n @param output TypedBuffer object (must be created first)\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data in bytes\n @return Error code or size in bytes of the main buffer inside output\n\n @note Output is filled on success, but undefined on error, and can only be\n free() in this case.\n @note ZL_TypedBuffer object is required to decompress String type"]
    pub fn ZL_DCtx_decompressTBuffer(
        dctx: *mut ZL_DCtx,
        output: *mut ZL_TypedBuffer,
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Decompresses a frame into multiple TypedBuffers.\n\n @param dctx Decompression context\n @param outputs Array of ZL_TypedBuffer* objects (must be created using\n                ZL_TypedBuffer_create or pre-allocated creation methods)\n @param nbOutputs Exact number of outputs expected from the frame\n                  (can be obtained from ZL_FrameInfo_getNumOutputs())\n @param compressed Pointer to compressed data\n @param cSize Size of compressed data in bytes\n @return Error code or number of decompressed TypedBuffers\n\n @note Requires exact number of outputs (not permissive)\n @note @p outputs are filled on success, but undefined on error\n @note TypedBuffer lifetimes are controlled by the caller"]
    pub fn ZL_DCtx_decompressMultiTBuffer(
        dctx: *mut ZL_DCtx,
        outputs: *mut *mut ZL_TypedBuffer,
        nbOutputs: usize,
        compressed: *const ::std::os::raw::c_void,
        cSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @brief Gets the type of the typed buffer.\n\n @param tbuffer Typed buffer object\n @return Type of the buffer"]
    pub fn ZL_TypedBuffer_type(tbuffer: *const ZL_TypedBuffer) -> ZL_Type;
}
extern "C" {
    #[doc = " @brief Gets the number of bytes written into the internal buffer.\n\n @param tbuffer Typed buffer object\n @return Number of bytes in the internal buffer.\n\n @note Generally equals eltWidth * nbElts,\n       but for String type equals sum(stringLens)\n @note ZL_DCtx_decompressTBuffer() returns the same value"]
    pub fn ZL_TypedBuffer_byteSize(tbuffer: *const ZL_TypedBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Gets direct access to the internal buffer for reading operation.\n\n @param tbuffer Typed buffer object\n @return Pointer to the beginning of buffer (for String type, points at the\n beginning of the first string).\n\n @warning Users must pay attention to buffer boundaries\n @note Buffer size is provided by ZL_TypedBuffer_byteSize()"]
    pub fn ZL_TypedBuffer_rPtr(tbuffer: *const ZL_TypedBuffer) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Gets the number of elements in the typed buffer.\n\n @param tbuffer Typed buffer object\n @return Number of elements in the buffer\n\n @note for Serial type, this is the number of bytes."]
    pub fn ZL_TypedBuffer_numElts(tbuffer: *const ZL_TypedBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Gets the size of each element for fixed-size types.\n\n @param tbuffer Typed buffer object\n @return Size of each element in bytes, or 0 for String type\n\n @note Not valid for String type (returns 0)"]
    pub fn ZL_TypedBuffer_eltWidth(tbuffer: *const ZL_TypedBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Gets pointer to the array of string lengths.\n\n @param tbuffer Typed buffer object\n @return Pointer to beginning of string lengths array, or NULL if incorrect\n type\n\n @note **Only valid for String type**\n @note Array size equals ZL_TypedBuffer_numElts()"]
    pub fn ZL_TypedBuffer_rStringLens(tbuffer: *const ZL_TypedBuffer) -> *const u32;
}
extern "C" {
    #[doc = " @brief Gets the size of the OpenZL header.\n\n Useful to determine header overhead.\n\n @param src Source compressed data\n @param srcSize Size of source data\n @return Header size in bytes, or error code\n\n @note This is a temporary function, not guaranteed to remain in future\n versions"]
    pub fn ZL_getHeaderSize(src: *const ::std::os::raw::c_void, srcSize: usize) -> ZL_Report;
}
pub type ZL_PipeDecoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> usize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_PipeDecoderDesc {
    pub CTid: ZL_IDType,
    pub dstBound_f: ZL_PipeDstCapacityFn,
    pub transform_f: ZL_PipeDecoderFn,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_PipeDecoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_PipeDecoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_PipeDecoderDesc>(),
        32usize,
        "Size of ZL_PipeDecoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_PipeDecoderDesc>(),
        8usize,
        "Alignment of ZL_PipeDecoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_PipeDecoderDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstBound_f) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_PipeDecoderDesc::dstBound_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_PipeDecoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_PipeDecoderDesc::name"
    );
}
extern "C" {
    #[doc = " Register a custom decoder transform, should it be needed during\n decompression of a zstrong frame.\n A decoder transform is expected to reverse the encoding transform of same\n @CTid.\n This function is specialized for the registration of simple pipe decoder\n transforms. Counterpart to ZL_Compressor_registerPipeEncoder()."]
    pub fn ZL_DCtx_registerPipeDecoder(
        dctx: *mut ZL_DCtx,
        dtd: *const ZL_PipeDecoderDesc,
    ) -> ZL_Report;
}
pub type ZL_SplitDstCapacityFn =
    ::std::option::Option<unsafe extern "C" fn(src: *const ZL_RBuffer) -> usize>;
pub type ZL_SplitDecoderFn =
    ::std::option::Option<unsafe extern "C" fn(dst: ZL_WBuffer, src: *const ZL_RBuffer) -> usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_SplitDecoderDesc {
    pub CTid: ZL_IDType,
    pub nbInputStreams: usize,
    pub dstBound_f: ZL_SplitDstCapacityFn,
    pub transform_f: ZL_SplitDecoderFn,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ZL_SplitDecoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_SplitDecoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_SplitDecoderDesc>(),
        40usize,
        "Size of ZL_SplitDecoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_SplitDecoderDesc>(),
        8usize,
        "Alignment of ZL_SplitDecoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CTid) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_SplitDecoderDesc::CTid"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbInputStreams) as usize - ptr as usize },
        8usize,
        "Offset of field: ZL_SplitDecoderDesc::nbInputStreams"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstBound_f) as usize - ptr as usize },
        16usize,
        "Offset of field: ZL_SplitDecoderDesc::dstBound_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_SplitDecoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_SplitDecoderDesc::name"
    );
}
extern "C" {
    #[doc = " Register a custom split decoder transform.\n This is supposed to be the reverse of the encoding transform of same @CTid.\n Counterpart to ZS2_registerSplitTransform()."]
    pub fn ZL_DCtx_registerSplitDecoder(
        dctx: *mut ZL_DCtx,
        dtd: *const ZL_SplitDecoderDesc,
    ) -> ZL_Report;
}
pub type ZL_TypedDecoderFn = ::std::option::Option<
    unsafe extern "C" fn(dictx: *mut ZL_Decoder, src: *mut *const ZL_Input) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_TypedDecoderDesc {
    pub gd: ZL_TypedGraphDesc,
    pub transform_f: ZL_TypedDecoderFn,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Decoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the dctx."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_TypedDecoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_TypedDecoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_TypedDecoderDesc>(),
        88usize,
        "Size of ZL_TypedDecoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_TypedDecoderDesc>(),
        8usize,
        "Alignment of ZL_TypedDecoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_TypedDecoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        24usize,
        "Offset of field: ZL_TypedDecoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        "Offset of field: ZL_TypedDecoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_TypedDecoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        64usize,
        "Offset of field: ZL_TypedDecoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a custom typed decoder transform.\n Counterpart to ZS2_registerTypedTransform().\n\n Note: Split transforms and Pipe Transforms\n can be converted into Typed transforms, since it's a strict superset."]
    pub fn ZL_DCtx_registerTypedDecoder(
        dctx: *mut ZL_DCtx,
        dtd: *const ZL_TypedDecoderDesc,
    ) -> ZL_Report;
}
pub type ZL_VODecoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        dictx: *mut ZL_Decoder,
        compulsorySrcs: *mut *const ZL_Input,
        nbCompulsorySrcs: usize,
        variableSrcs: *mut *const ZL_Input,
        nbVariableSrcs: usize,
    ) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_VODecoderDesc {
    pub gd: ZL_VOGraphDesc,
    pub transform_f: ZL_VODecoderFn,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Decoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the dctx."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_VODecoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_VODecoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_VODecoderDesc>(),
        104usize,
        "Size of ZL_VODecoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_VODecoderDesc>(),
        8usize,
        "Alignment of ZL_VODecoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_VODecoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        40usize,
        "Offset of field: ZL_VODecoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        "Offset of field: ZL_VODecoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        56usize,
        "Offset of field: ZL_VODecoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_VODecoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register a variable output decoder transform.\n Counterpart to ZS2_registerVOTransform()."]
    pub fn ZL_DCtx_registerVODecoder(dctx: *mut ZL_DCtx, dtd: *const ZL_VODecoderDesc)
        -> ZL_Report;
}
pub type ZL_MIDecoderFn = ::std::option::Option<
    unsafe extern "C" fn(
        dictx: *mut ZL_Decoder,
        compulsorySrcs: *mut *const ZL_Input,
        nbCompulsorySrcs: usize,
        variableSrcs: *mut *const ZL_Input,
        nbVariableSrcs: usize,
    ) -> ZL_Report,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_MIDecoderDesc {
    pub gd: ZL_MIGraphDesc,
    pub transform_f: ZL_MIDecoderFn,
    pub name: *const ::std::os::raw::c_char,
    pub trStateMgr: ZL_CodecStateManager,
    #[doc = " Optionally an opaque pointer that can be queried with\n ZL_Decoder_getOpaquePtr().\n OpenZL unconditionally takes ownership of this pointer, even if\n registration fails, and it lives for the lifetime of the dctx."]
    pub opaque: ZL_OpaquePtr,
}
#[test]
fn bindgen_test_layout_ZL_MIDecoderDesc() {
    const UNINIT: ::std::mem::MaybeUninit<ZL_MIDecoderDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ZL_MIDecoderDesc>(),
        128usize,
        "Size of ZL_MIDecoderDesc"
    );
    assert_eq!(
        ::std::mem::align_of::<ZL_MIDecoderDesc>(),
        8usize,
        "Alignment of ZL_MIDecoderDesc"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        "Offset of field: ZL_MIDecoderDesc::gd"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform_f) as usize - ptr as usize },
        64usize,
        "Offset of field: ZL_MIDecoderDesc::transform_f"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        72usize,
        "Offset of field: ZL_MIDecoderDesc::name"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trStateMgr) as usize - ptr as usize },
        80usize,
        "Offset of field: ZL_MIDecoderDesc::trStateMgr"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        104usize,
        "Offset of field: ZL_MIDecoderDesc::opaque"
    );
}
extern "C" {
    #[doc = " Register an MI decoder transform.\n Counterpart to ZS2_registerMITransform()."]
    pub fn ZL_DCtx_registerMIDecoder(dctx: *mut ZL_DCtx, dtd: *const ZL_MIDecoderDesc)
        -> ZL_Report;
}
extern "C" {
    pub fn ZL_Decoder_getScratchSpace(
        dictx: *mut ZL_Decoder,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ZL_Decoder_create1OutStream(
        dictx: *mut ZL_Decoder,
        eltsCapacity: usize,
        eltWidth: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Decoder_create1StringStream(
        dictx: *mut ZL_Decoder,
        nbStringsMax: usize,
        sumStringLensMax: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Decoder_createTypedStream(
        dictx: *mut ZL_Decoder,
        index: ::std::os::raw::c_int,
        eltsCapacity: usize,
        eltWidth: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Decoder_createStringStream(
        dictx: *mut ZL_Decoder,
        index: ::std::os::raw::c_int,
        nbStringsMax: usize,
        sumStringLensMax: usize,
    ) -> *mut ZL_Output;
}
extern "C" {
    pub fn ZL_Decoder_getCodecHeader(dictx: *const ZL_Decoder) -> ZL_RBuffer;
}
extern "C" {
    #[doc = " @returns The opaque pointer provided in the transform description.\n @warning Usage of the opaque pointer must be thread-safe, and must\n not not modify the state in any way that impacts decoding!"]
    pub fn ZL_Decoder_getOpaquePtr(dictx: *const ZL_Decoder) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns Returns a state, as generated by the Transform's State Manager."]
    pub fn ZL_Decoder_getState(dictx: *const ZL_Decoder) -> *mut ::std::os::raw::c_void;
}
pub const ZL_GraphType_standard: ZL_GraphType = 0;
pub const ZL_GraphType_static: ZL_GraphType = 1;
pub const ZL_GraphType_selector: ZL_GraphType = 2;
pub const ZL_GraphType_function: ZL_GraphType = 3;
pub const ZL_GraphType_multiInput: ZL_GraphType = 4;
pub const ZL_GraphType_parameterized: ZL_GraphType = 5;
pub const ZL_GraphType_segmenter: ZL_GraphType = 6;
pub type ZL_GraphType = ::std::os::raw::c_uint;
pub type ZL_Compressor_ForEachGraphCallback = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        compressor: *const ZL_Compressor,
        graphID: ZL_GraphID,
    ) -> ZL_Report,
>;
extern "C" {
    #[doc = " Calls @p callback on every graph registered in the @p compressor.\n If @p callback returns an error, short-circuit and return that error.\n @returns Success if all callbacks succeed, or the first error.\n @note The callback will not be called on standard graphs, since they\n aren't registered in the @p compressor."]
    pub fn ZL_Compressor_forEachGraph(
        compressor: *const ZL_Compressor,
        callback: ZL_Compressor_ForEachGraphCallback,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ZL_Report;
}
pub type ZL_Compressor_ForEachNodeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        compressor: *const ZL_Compressor,
        graphID: ZL_NodeID,
    ) -> ZL_Report,
>;
extern "C" {
    #[doc = " Calls @p callback on every node registered in the @p compressor.\n If @p callback returns an error, short-circuit and return that error.\n @returns Success if all callbacks succeed, or the first error.\n @note The callback will not be called on standard nodes, since they\n aren't registered in the @p compressor."]
    pub fn ZL_Compressor_forEachNode(
        compressor: *const ZL_Compressor,
        callback: ZL_Compressor_ForEachNodeCallback,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ZL_Report;
}
pub type ZL_Compressor_ForEachParamCallback = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        param: ZL_CParam,
        val: ::std::os::raw::c_int,
    ) -> ZL_Report,
>;
extern "C" {
    #[doc = " Calls @p callback on every param set in the @p compressor.\n If @p callback returns an error, short-circuit and return that error.\n @returns Success if all callbacks succeed, or the first error.\n @note The callback will not be called on params that are equal to\n the default value (0)."]
    pub fn ZL_Compressor_forEachParam(
        compressor: *const ZL_Compressor,
        callback: ZL_Compressor_ForEachParamCallback,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @param[out] graphID If the function returns true, filled with\n the starting GraphID, otherwise filled with ZL_GRAPH_ILLEGAL.\n @returns True iff the compressor has the starting GraphID set."]
    pub fn ZL_Compressor_getStartingGraphID(
        compressor: *const ZL_Compressor,
        graphID: *mut ZL_GraphID,
    ) -> bool;
}
extern "C" {
    #[doc = " @returns The @ref ZL_GraphType of the given graph.\n @note This is the original type the graph was registered with."]
    pub fn ZL_Compressor_getGraphType(
        compressor: *const ZL_Compressor,
        graph: ZL_GraphID,
    ) -> ZL_GraphType;
}
extern "C" {
    #[doc = " @returns the (optional) @p name given to this graphid.\n When none provided, returns \"\".\n When graphid is illegal (invalid), returns NULL."]
    pub fn ZL_Compressor_Graph_getName(
        cgraph: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns The input stream types that @p graphid is compatible with.\n @pre @p graph must be valid, and must have a single input stream"]
    pub fn ZL_Compressor_Graph_getInput0Mask(
        cgraph: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns The input stream types that @p graphid input @p inputIdx is\n compatible with."]
    pub fn ZL_Compressor_Graph_getInputMask(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
        inputIdx: usize,
    ) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns The number of input streams that @p graphid expects."]
    pub fn ZL_Compressor_Graph_getNumInputs(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> usize;
}
extern "C" {
    #[doc = " @returns True if @p graphid is a multi input graph whose last\n input may show up zero or more times."]
    pub fn ZL_Compressor_Graph_isVariableInput(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> bool;
}
extern "C" {
    #[doc = " @returns The head node of the graph if @p graphid is a static graph,\n otherwise returns ZL_NODE_ILLEGAL."]
    pub fn ZL_Compressor_Graph_getHeadNode(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " @returns If the provided @p graphid was created by modifying another\n          existing graph, i.e., its type is `ZL_GraphType_parameterized`,\n          the `ZL_GraphID` of that other graph. Otherwise, it returns\n          `ZL_GRAPH_ILLEGAL`."]
    pub fn ZL_Compressor_Graph_getBaseGraphID(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_GraphID;
}
extern "C" {
    #[doc = " @returns The successor of the head node in the graph if @p graphid is a\n static graph, otherwise returns an empty list.\n @note The array is valid for the lifetime of the @p compressor."]
    pub fn ZL_Compressor_Graph_getSuccessors(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_GraphIDList;
}
extern "C" {
    #[doc = " @returns The custom nodes of @p graphid, which is only non-empty for\n dynamic and multi-input graphs.\n @note The array is valid for the lifetime of the @p compressor."]
    pub fn ZL_Compressor_Graph_getCustomNodes(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_NodeIDList;
}
extern "C" {
    #[doc = " @returns The custom graphs of @p graphid, which is only non-empty for\n selector, dynamic, and multi-input graphs.\n @note The array is valid for the lifetime of the @p compressor."]
    pub fn ZL_Compressor_Graph_getCustomGraphs(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_GraphIDList;
}
extern "C" {
    #[doc = " @returns The local params of @p graphid.\n @note The params for the lifetime of the @p compressor."]
    pub fn ZL_Compressor_Graph_getLocalParams(
        compressor: *const ZL_Compressor,
        graphid: ZL_GraphID,
    ) -> ZL_LocalParams;
}
extern "C" {
    #[doc = " @returns The number of input streams that @p node expects\n in the context of the @p cgraph."]
    pub fn ZL_Compressor_Node_getNumInputs(cgraph: *const ZL_Compressor, node: ZL_NodeID) -> usize;
}
extern "C" {
    #[doc = " @returns The input stream type that @p node expects\n @pre @p node must be valid, and must have a single input stream"]
    pub fn ZL_Compressor_Node_getInput0Type(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns The input stream type that @p node has at index @p inputIndex in\n the context of the @p cgraph\n\n @pre @p inputIndex is less than #ZL_Compressor_Node_getNumInputs(@p cgraph ,\n @p node). It is an error to pass an @p inputIndex greater or equal to the\n number of inputs. Note that all input streams within a group of variable\n inputs share the same @p inputIndex."]
    pub fn ZL_Compressor_Node_getInputType(
        cgraph: *const ZL_Compressor,
        nodeid: ZL_NodeID,
        inputIndex: ZL_IDType,
    ) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns True if @p nodeid is a multi input codec whose last\n input may show up zero or more times."]
    pub fn ZL_Compressor_Node_isVariableInput(
        compressor: *const ZL_Compressor,
        nodeid: ZL_NodeID,
    ) -> bool;
}
extern "C" {
    #[doc = " @returns The number of output outcomes that @p node has\n in the context of the @p cgraph."]
    pub fn ZL_Compressor_Node_getNumOutcomes(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> usize;
}
extern "C" {
    #[doc = " @returns The number of variable output that @p node has\n in the context of the @p cgraph."]
    pub fn ZL_Compressor_Node_getNumVariableOutcomes(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> usize;
}
extern "C" {
    #[doc = " @returns The output stream type that @p node has at index @p outputIndex in\n the context of the @p cgraph\n\n @pre @p outputIndex is less than #ZS2_Compressor_Node_getNbOutputs(@p cgraph\n , @p node)"]
    pub fn ZL_Compressor_Node_getOutputType(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
        outputIndex: ::std::os::raw::c_int,
    ) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns The local params of @p nodeid.\n @note The params for the lifetime of the @p compressor."]
    pub fn ZL_Compressor_Node_getLocalParams(
        cgraph: *const ZL_Compressor,
        nodeid: ZL_NodeID,
    ) -> ZL_LocalParams;
}
extern "C" {
    #[doc = " @returns the max format version that @p node supports\n in the context of the @p cgraph."]
    pub fn ZL_Compressor_Node_getMaxVersion(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @returns the min format version that @p node supports\n in the context of the @p cgraph."]
    pub fn ZL_Compressor_Node_getMinVersion(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @returns The transform ID for the node, which is the ID that is written into\n the frame header, and how we determine which decoder to use."]
    pub fn ZL_Compressor_Node_getCodecID(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> ZL_IDType;
}
extern "C" {
    #[doc = " @returns If the provided @p node was created by modifying another existing\n node, the `ZL_NodeID` of that other node. Otherwise, `ZL_NODE_ILLEGAL`."]
    pub fn ZL_Compressor_Node_getBaseNodeID(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> ZL_NodeID;
}
extern "C" {
    #[doc = " @returns The name of the node if available, else \"\", and returns NULL if @p\n node is invalid."]
    pub fn ZL_Compressor_Node_getName(
        cgraph: *const ZL_Compressor,
        node: ZL_NodeID,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns a boolean value indicating whether the node is standard or not."]
    pub fn ZL_Compressor_Node_isStandard(cgraph: *const ZL_Compressor, node: ZL_NodeID) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_ReflectionCtx_s {
    _unused: [u8; 0],
}
#[doc = " Reflection API for introspecting a compressed frame.\n\n 1. Create a reflection context with ZL_ReflectionCtx_create().\n 2. Register the transforms used in the frame with\n    ZL_ReflectionCtx_registerTypedDecoder() and friends.\n 3. Set the compressed frame to process with\n    ZL_ReflectionCtx_setCompressedFrame().\n 4. Get the information you need with the various\n ZS2_ReflectionCtx_get*()\n 5. Free the context with ZL_ReflectionCtx_free().\n\n NOTE: This API is guaranteed to be safe on corrupted input.\n WARNING: Logic errors in the API usage will crash the process.\n For example trying to call any getter (e.g.\n ZL_ReflectionCtx_getNumStreams_lastChunk()) before calling\n ZL_ReflectionCtx_setCompressedFrame() and getting a successful return\n code."]
pub type ZL_ReflectionCtx = ZL_ReflectionCtx_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_DataInfo_s {
    _unused: [u8; 0],
}
pub type ZL_DataInfo = ZL_DataInfo_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZL_CodecInfo_s {
    _unused: [u8; 0],
}
pub type ZL_CodecInfo = ZL_CodecInfo_s;
extern "C" {
    pub fn ZL_ReflectionCtx_create() -> *mut ZL_ReflectionCtx;
}
extern "C" {
    pub fn ZL_ReflectionCtx_free(rctx: *mut ZL_ReflectionCtx);
}
extern "C" {
    #[doc = " @returns The dctx that will be used for decompression so the user\n can set parameters and register custom transforms if the helpers\n provided aren't sufficient.\n\n @pre Must be called before ZL_ReflectionCtx_setCompressedFrame()."]
    pub fn ZL_ReflectionCtx_getDCtx(rctx: *mut ZL_ReflectionCtx) -> *mut ZL_DCtx;
}
extern "C" {
    #[doc = " Registers a custom transform to be used when decoding the frame.\n @pre Must be called before ZL_ReflectionCtx_setCompressedFrame()."]
    pub fn ZL_ReflectionCtx_registerTypedDecoder(
        rctx: *mut ZL_ReflectionCtx,
        dtd: *const ZL_TypedDecoderDesc,
    );
}
extern "C" {
    #[doc = " Registers a custom transform to be used when decoding the frame.\n @pre Must be called before ZL_ReflectionCtx_setCompressedFrame()."]
    pub fn ZL_ReflectionCtx_registerVODecoder(
        rctx: *mut ZL_ReflectionCtx,
        dtd: *const ZL_VODecoderDesc,
    );
}
extern "C" {
    #[doc = " Registers a custom transform to be used when decoding the frame.\n @pre Must be called before ZL_ReflectionCtx_setCompressedFrame()."]
    pub fn ZL_ReflectionCtx_registerMIDecoder(
        rctx: *mut ZL_ReflectionCtx,
        dtd: *const ZL_MIDecoderDesc,
    );
}
extern "C" {
    #[doc = " Decompresses the frame in @p src and build all the information needed to\n introspect the frame.\n\n @pre Must only be called once per @p rctx.\n\n @returns ZL_returnSuccess() if decompression sueeeded."]
    pub fn ZL_ReflectionCtx_setCompressedFrame(
        rctx: *mut ZL_ReflectionCtx,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
    ) -> ZL_Report;
}
extern "C" {
    #[doc = " @returns The frame format version.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getFrameFormatVersion(rctx: *const ZL_ReflectionCtx) -> u32;
}
extern "C" {
    #[doc = " @returns The size of the frame header.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getFrameHeaderSize(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The size of the frame footer.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getFrameFooterSize(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The total size of all the transform headers.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getTotalTransformHeaderSize_lastChunk(
        rctx: *const ZL_ReflectionCtx,
    ) -> usize;
}
extern "C" {
    #[doc = " @returns The total number of streams in the decoder graph. This includes\n streams stored in the frame, input streams to the frame, and intermediate\n streams.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getNumStreams_lastChunk(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The stream at @p index\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success.\n @pre @p index is valid."]
    pub fn ZL_ReflectionCtx_getStream_lastChunk(
        rctx: *const ZL_ReflectionCtx,
        index: usize,
    ) -> *const ZL_DataInfo;
}
extern "C" {
    #[doc = " @returns The number of input streams to the compressed frame.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getNumInputs(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The input stream at @p index\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success.\n @pre @p index is valid."]
    pub fn ZL_ReflectionCtx_getInput(
        rctx: *const ZL_ReflectionCtx,
        index: usize,
    ) -> *const ZL_DataInfo;
}
extern "C" {
    #[doc = " @returns The number of streams stored in the compressed frame.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getNumStoredOutputs_lastChunk(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The stored stream at @p index\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success.\n @pre @p index is valid."]
    pub fn ZL_ReflectionCtx_getStoredOutput_lastChunk(
        rctx: *const ZL_ReflectionCtx,
        index: usize,
    ) -> *const ZL_DataInfo;
}
extern "C" {
    #[doc = " @returns the number of transforms that are run during the decoding process.\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success."]
    pub fn ZL_ReflectionCtx_getNumCodecs_lastChunk(rctx: *const ZL_ReflectionCtx) -> usize;
}
extern "C" {
    #[doc = " @returns The transform at @p index\n @pre ZL_ReflectionCtx_setCompressedFrame() returned success.\n @pre @p index is valid."]
    pub fn ZL_ReflectionCtx_getCodec_lastChunk(
        rctx: *const ZL_ReflectionCtx,
        index: usize,
    ) -> *const ZL_CodecInfo;
}
extern "C" {
    #[doc = " @returns The type of the stream."]
    pub fn ZL_DataInfo_getType(si: *const ZL_DataInfo) -> ZL_Type;
}
extern "C" {
    #[doc = " @returns The number of elements in the stream."]
    pub fn ZL_DataInfo_getNumElts(si: *const ZL_DataInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The element width of the stream."]
    pub fn ZL_DataInfo_getEltWidth(si: *const ZL_DataInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The content size of the stream.\n For non-string streams equal to nbElts * eltWidth.\n For string streams equal to the sum of the lengths."]
    pub fn ZL_DataInfo_getContentSize(si: *const ZL_DataInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The index for which ZL_ReflectionCtx_getStream_lastChunk() returns\n this stream."]
    pub fn ZL_DataInfo_getIndex(si: *const ZL_DataInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The data pointer for the stream."]
    pub fn ZL_DataInfo_getDataPtr(si: *const ZL_DataInfo) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns The length pointer for the stream if the type is\n ZL_Type_string.\n @pre The type is ZL_Type_string."]
    pub fn ZL_DataInfo_getLengthsPtr(si: *const ZL_DataInfo) -> *const u32;
}
extern "C" {
    #[doc = " @returns The transform that produced this stream or NULL\n if the stream is stored in the frame."]
    pub fn ZL_DataInfo_getProducerCodec(si: *const ZL_DataInfo) -> *const ZL_CodecInfo;
}
extern "C" {
    #[doc = " @returns The transform that consumes this stream or NULL\n if the stream is an input stream to the frame."]
    pub fn ZL_DataInfo_getConsumerCodec(si: *const ZL_DataInfo) -> *const ZL_CodecInfo;
}
extern "C" {
    #[doc = " @returns The name of the transform"]
    pub fn ZL_CodecInfo_getName(ti: *const ZL_CodecInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns The transform ID"]
    pub fn ZL_CodecInfo_getCodecID(ti: *const ZL_CodecInfo) -> ZL_IDType;
}
extern "C" {
    #[doc = " @returns true iff the transform is a standard transform."]
    pub fn ZL_CodecInfo_isStandardCodec(ti: *const ZL_CodecInfo) -> bool;
}
extern "C" {
    #[doc = " @returns true iff the transform is a custom transform."]
    pub fn ZL_CodecInfo_isCustomCodec(ti: *const ZL_CodecInfo) -> bool;
}
extern "C" {
    #[doc = " @returns The index for which ZL_ReflectionCtx_getCodec_lastChunk() returns\n this transform."]
    pub fn ZL_CodecInfo_getIndex(ti: *const ZL_CodecInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The header pointer for the transform."]
    pub fn ZL_CodecInfo_getHeaderPtr(ti: *const ZL_CodecInfo) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @returns The header size of the transform."]
    pub fn ZL_CodecInfo_getHeaderSize(ti: *const ZL_CodecInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The number of input streams to the transform.\n Input streams are streams that are consumed by the encoder and produced by\n the decoder."]
    pub fn ZL_CodecInfo_getNumInputs(ti: *const ZL_CodecInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The input stream of the transform at index @p index\n @pre index is valid"]
    pub fn ZL_CodecInfo_getInput(ti: *const ZL_CodecInfo, index: usize) -> *const ZL_DataInfo;
}
extern "C" {
    #[doc = " @returns The number of output streams to the transform.\n Output streams are streams that are produced by the encoder and consumed by\n the decoder."]
    pub fn ZL_CodecInfo_getNumOutputs(ti: *const ZL_CodecInfo) -> usize;
}
extern "C" {
    #[doc = " @returns The output stream of the transform at index @p index\n @pre index is valid"]
    pub fn ZL_CodecInfo_getOutput(ti: *const ZL_CodecInfo, index: usize) -> *const ZL_DataInfo;
}
extern "C" {
    #[doc = " @returns The number of output streams of the transform that are\n variable outputs. Necessarily no greater than\n ZL_CodecInfo_getOutput()."]
    pub fn ZL_CodecInfo_getNumVariableOutputs(ti: *const ZL_CodecInfo) -> usize;
}
